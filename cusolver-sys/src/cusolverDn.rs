/* automatically generated by rust-bindgen 0.64.0 */

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

pub const _MATH_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const cudaHostAllocDefault: u32 = 0;
pub const cudaHostAllocPortable: u32 = 1;
pub const cudaHostAllocMapped: u32 = 2;
pub const cudaHostAllocWriteCombined: u32 = 4;
pub const cudaHostRegisterDefault: u32 = 0;
pub const cudaHostRegisterPortable: u32 = 1;
pub const cudaHostRegisterMapped: u32 = 2;
pub const cudaHostRegisterIoMemory: u32 = 4;
pub const cudaHostRegisterReadOnly: u32 = 8;
pub const cudaPeerAccessDefault: u32 = 0;
pub const cudaStreamDefault: u32 = 0;
pub const cudaStreamNonBlocking: u32 = 1;
pub const cudaEventDefault: u32 = 0;
pub const cudaEventBlockingSync: u32 = 1;
pub const cudaEventDisableTiming: u32 = 2;
pub const cudaEventInterprocess: u32 = 4;
pub const cudaEventRecordDefault: u32 = 0;
pub const cudaEventRecordExternal: u32 = 1;
pub const cudaEventWaitDefault: u32 = 0;
pub const cudaEventWaitExternal: u32 = 1;
pub const cudaDeviceScheduleAuto: u32 = 0;
pub const cudaDeviceScheduleSpin: u32 = 1;
pub const cudaDeviceScheduleYield: u32 = 2;
pub const cudaDeviceScheduleBlockingSync: u32 = 4;
pub const cudaDeviceBlockingSync: u32 = 4;
pub const cudaDeviceScheduleMask: u32 = 7;
pub const cudaDeviceMapHost: u32 = 8;
pub const cudaDeviceLmemResizeToMax: u32 = 16;
pub const cudaDeviceMask: u32 = 31;
pub const cudaArrayDefault: u32 = 0;
pub const cudaArrayLayered: u32 = 1;
pub const cudaArraySurfaceLoadStore: u32 = 2;
pub const cudaArrayCubemap: u32 = 4;
pub const cudaArrayTextureGather: u32 = 8;
pub const cudaArrayColorAttachment: u32 = 32;
pub const cudaArraySparse: u32 = 64;
pub const cudaIpcMemLazyEnablePeerAccess: u32 = 1;
pub const cudaMemAttachGlobal: u32 = 1;
pub const cudaMemAttachHost: u32 = 2;
pub const cudaMemAttachSingle: u32 = 4;
pub const cudaOccupancyDefault: u32 = 0;
pub const cudaOccupancyDisableCachingOverride: u32 = 1;
pub const cudaCooperativeLaunchMultiDeviceNoPreSync: u32 = 1;
pub const cudaCooperativeLaunchMultiDeviceNoPostSync: u32 = 2;
pub const cudaArraySparsePropertiesSingleMipTail: u32 = 1;
pub const CUDA_IPC_HANDLE_SIZE: u32 = 64;
pub const cudaExternalMemoryDedicated: u32 = 1;
pub const cudaExternalSemaphoreSignalSkipNvSciBufMemSync: u32 = 1;
pub const cudaExternalSemaphoreWaitSkipNvSciBufMemSync: u32 = 2;
pub const cudaNvSciSyncAttrSignal: u32 = 1;
pub const cudaNvSciSyncAttrWait: u32 = 2;
pub const CUBLAS_VER_MAJOR: u32 = 11;
pub const CUBLAS_VER_MINOR: u32 = 5;
pub const CUBLAS_VER_PATCH: u32 = 4;
pub const CUBLAS_VER_BUILD: u32 = 8;
pub const CUBLAS_VERSION: u32 = 11504;
pub const _INTTYPES_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"ld\0";
pub const PRIiMAX: &[u8; 3usize] = b"li\0";
pub const PRIoMAX: &[u8; 3usize] = b"lo\0";
pub const PRIuMAX: &[u8; 3usize] = b"lu\0";
pub const PRIxMAX: &[u8; 3usize] = b"lx\0";
pub const PRIXMAX: &[u8; 3usize] = b"lX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"ld\0";
pub const SCNiMAX: &[u8; 3usize] = b"li\0";
pub const SCNoMAX: &[u8; 3usize] = b"lo\0";
pub const SCNuMAX: &[u8; 3usize] = b"lu\0";
pub const SCNxMAX: &[u8; 3usize] = b"lx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const CUSOLVER_VER_MAJOR: u32 = 11;
pub const CUSOLVER_VER_MINOR: u32 = 2;
pub const CUSOLVER_VER_PATCH: u32 = 0;
pub const CUSOLVER_VER_BUILD: u32 = 120;
pub const CUSOLVER_VERSION: u32 = 11200;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cusolverDnContext {
    _unused: [u8; 0],
}
pub type cusolverDnHandle_t = *mut cusolverDnContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct syevjInfo {
    _unused: [u8; 0],
}
pub type syevjInfo_t = *mut syevjInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gesvdjInfo {
    _unused: [u8; 0],
}
pub type gesvdjInfo_t = *mut gesvdjInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cusolverDnIRSParams {
    _unused: [u8; 0],
}
pub type cusolverDnIRSParams_t = *mut cusolverDnIRSParams;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cusolverDnIRSInfos {
    _unused: [u8; 0],
}
pub type cusolverDnIRSInfos_t = *mut cusolverDnIRSInfos;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cusolverDnParams {
    _unused: [u8; 0],
}
pub type cusolverDnParams_t = *mut cusolverDnParams;
pub const cusolverDnFunction_t_CUSOLVERDN_GETRF: cusolverDnFunction_t = 0;
pub type cusolverDnFunction_t = ::std::os::raw::c_uint;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
// FIXME: generated consts multiple times.
//pub const FP_NAN: _bindgen_ty_1 = 0;
//pub const FP_INFINITE: _bindgen_ty_1 = 1;
//pub const FP_ZERO: _bindgen_ty_1 = 2;
//pub const FP_SUBNORMAL: _bindgen_ty_1 = 3;
//pub const FP_NORMAL: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char1 {
    pub x: ::std::os::raw::c_schar,
}
#[test]
fn bindgen_test_layout_char1() {
    const UNINIT: ::std::mem::MaybeUninit<char1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<char1>(),
        1usize,
        concat!("Size of: ", stringify!(char1))
    );
    assert_eq!(
        ::std::mem::align_of::<char1>(),
        1usize,
        concat!("Alignment of ", stringify!(char1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(char1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar1 {
    pub x: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar1() {
    const UNINIT: ::std::mem::MaybeUninit<uchar1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uchar1>(),
        1usize,
        concat!("Size of: ", stringify!(uchar1))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar1>(),
        1usize,
        concat!("Alignment of ", stringify!(uchar1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uchar1), "::", stringify!(x))
    );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct char2 {
    pub x: ::std::os::raw::c_schar,
    pub y: ::std::os::raw::c_schar,
}
#[test]
fn bindgen_test_layout_char2() {
    const UNINIT: ::std::mem::MaybeUninit<char2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<char2>(),
        2usize,
        concat!("Size of: ", stringify!(char2))
    );
    assert_eq!(
        ::std::mem::align_of::<char2>(),
        2usize,
        concat!("Alignment of ", stringify!(char2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(char2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        1usize,
        concat!("Offset of field: ", stringify!(char2), "::", stringify!(y))
    );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct uchar2 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar2() {
    const UNINIT: ::std::mem::MaybeUninit<uchar2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uchar2>(),
        2usize,
        concat!("Size of: ", stringify!(uchar2))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar2>(),
        2usize,
        concat!("Alignment of ", stringify!(uchar2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uchar2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        1usize,
        concat!("Offset of field: ", stringify!(uchar2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char3 {
    pub x: ::std::os::raw::c_schar,
    pub y: ::std::os::raw::c_schar,
    pub z: ::std::os::raw::c_schar,
}
#[test]
fn bindgen_test_layout_char3() {
    const UNINIT: ::std::mem::MaybeUninit<char3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<char3>(),
        3usize,
        concat!("Size of: ", stringify!(char3))
    );
    assert_eq!(
        ::std::mem::align_of::<char3>(),
        1usize,
        concat!("Alignment of ", stringify!(char3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(char3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        1usize,
        concat!("Offset of field: ", stringify!(char3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(char3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar3 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
    pub z: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar3() {
    const UNINIT: ::std::mem::MaybeUninit<uchar3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uchar3>(),
        3usize,
        concat!("Size of: ", stringify!(uchar3))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar3>(),
        1usize,
        concat!("Alignment of ", stringify!(uchar3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uchar3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        1usize,
        concat!("Offset of field: ", stringify!(uchar3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(uchar3), "::", stringify!(z))
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct char4 {
    pub x: ::std::os::raw::c_schar,
    pub y: ::std::os::raw::c_schar,
    pub z: ::std::os::raw::c_schar,
    pub w: ::std::os::raw::c_schar,
}
#[test]
fn bindgen_test_layout_char4() {
    const UNINIT: ::std::mem::MaybeUninit<char4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<char4>(),
        4usize,
        concat!("Size of: ", stringify!(char4))
    );
    assert_eq!(
        ::std::mem::align_of::<char4>(),
        4usize,
        concat!("Alignment of ", stringify!(char4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(char4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        1usize,
        concat!("Offset of field: ", stringify!(char4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(char4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        3usize,
        concat!("Offset of field: ", stringify!(char4), "::", stringify!(w))
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uchar4 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
    pub z: ::std::os::raw::c_uchar,
    pub w: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar4() {
    const UNINIT: ::std::mem::MaybeUninit<uchar4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uchar4>(),
        4usize,
        concat!("Size of: ", stringify!(uchar4))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar4>(),
        4usize,
        concat!("Alignment of ", stringify!(uchar4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        1usize,
        concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        3usize,
        concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short1 {
    pub x: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_short1() {
    const UNINIT: ::std::mem::MaybeUninit<short1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<short1>(),
        2usize,
        concat!("Size of: ", stringify!(short1))
    );
    assert_eq!(
        ::std::mem::align_of::<short1>(),
        2usize,
        concat!("Alignment of ", stringify!(short1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(short1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort1 {
    pub x: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort1() {
    const UNINIT: ::std::mem::MaybeUninit<ushort1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ushort1>(),
        2usize,
        concat!("Size of: ", stringify!(ushort1))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort1>(),
        2usize,
        concat!("Alignment of ", stringify!(ushort1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort1),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct short2 {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_short2() {
    const UNINIT: ::std::mem::MaybeUninit<short2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<short2>(),
        4usize,
        concat!("Size of: ", stringify!(short2))
    );
    assert_eq!(
        ::std::mem::align_of::<short2>(),
        4usize,
        concat!("Alignment of ", stringify!(short2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(short2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(short2), "::", stringify!(y))
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ushort2 {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort2() {
    const UNINIT: ::std::mem::MaybeUninit<ushort2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ushort2>(),
        4usize,
        concat!("Size of: ", stringify!(ushort2))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort2>(),
        4usize,
        concat!("Alignment of ", stringify!(ushort2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short3 {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub z: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_short3() {
    const UNINIT: ::std::mem::MaybeUninit<short3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<short3>(),
        6usize,
        concat!("Size of: ", stringify!(short3))
    );
    assert_eq!(
        ::std::mem::align_of::<short3>(),
        2usize,
        concat!("Alignment of ", stringify!(short3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(short3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(short3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(short3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort3 {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
    pub z: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort3() {
    const UNINIT: ::std::mem::MaybeUninit<ushort3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ushort3>(),
        6usize,
        concat!("Size of: ", stringify!(ushort3))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort3>(),
        2usize,
        concat!("Alignment of ", stringify!(ushort3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct short4 {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub z: ::std::os::raw::c_short,
    pub w: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_short4() {
    const UNINIT: ::std::mem::MaybeUninit<short4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<short4>(),
        8usize,
        concat!("Size of: ", stringify!(short4))
    );
    assert_eq!(
        ::std::mem::align_of::<short4>(),
        8usize,
        concat!("Alignment of ", stringify!(short4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(short4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(short4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(short4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        6usize,
        concat!("Offset of field: ", stringify!(short4), "::", stringify!(w))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ushort4 {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
    pub z: ::std::os::raw::c_ushort,
    pub w: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort4() {
    const UNINIT: ::std::mem::MaybeUninit<ushort4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ushort4>(),
        8usize,
        concat!("Size of: ", stringify!(ushort4))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort4>(),
        8usize,
        concat!("Alignment of ", stringify!(ushort4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort4),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int1 {
    pub x: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_int1() {
    const UNINIT: ::std::mem::MaybeUninit<int1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<int1>(),
        4usize,
        concat!("Size of: ", stringify!(int1))
    );
    assert_eq!(
        ::std::mem::align_of::<int1>(),
        4usize,
        concat!("Alignment of ", stringify!(int1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(int1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint1 {
    pub x: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uint1() {
    const UNINIT: ::std::mem::MaybeUninit<uint1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uint1>(),
        4usize,
        concat!("Size of: ", stringify!(uint1))
    );
    assert_eq!(
        ::std::mem::align_of::<uint1>(),
        4usize,
        concat!("Alignment of ", stringify!(uint1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uint1), "::", stringify!(x))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct int2 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_int2() {
    const UNINIT: ::std::mem::MaybeUninit<int2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<int2>(),
        8usize,
        concat!("Size of: ", stringify!(int2))
    );
    assert_eq!(
        ::std::mem::align_of::<int2>(),
        8usize,
        concat!("Alignment of ", stringify!(int2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(int2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(int2), "::", stringify!(y))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct uint2 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uint2() {
    const UNINIT: ::std::mem::MaybeUninit<uint2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uint2>(),
        8usize,
        concat!("Size of: ", stringify!(uint2))
    );
    assert_eq!(
        ::std::mem::align_of::<uint2>(),
        8usize,
        concat!("Alignment of ", stringify!(uint2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uint2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(uint2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int3 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_int3() {
    const UNINIT: ::std::mem::MaybeUninit<int3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<int3>(),
        12usize,
        concat!("Size of: ", stringify!(int3))
    );
    assert_eq!(
        ::std::mem::align_of::<int3>(),
        4usize,
        concat!("Alignment of ", stringify!(int3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(int3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(int3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(int3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint3 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uint3() {
    const UNINIT: ::std::mem::MaybeUninit<uint3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uint3>(),
        12usize,
        concat!("Size of: ", stringify!(uint3))
    );
    assert_eq!(
        ::std::mem::align_of::<uint3>(),
        4usize,
        concat!("Alignment of ", stringify!(uint3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uint3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(uint3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(uint3), "::", stringify!(z))
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct int4 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_int4() {
    const UNINIT: ::std::mem::MaybeUninit<int4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<int4>(),
        16usize,
        concat!("Size of: ", stringify!(int4))
    );
    assert_eq!(
        ::std::mem::align_of::<int4>(),
        16usize,
        concat!("Alignment of ", stringify!(int4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(int4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(int4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(int4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        12usize,
        concat!("Offset of field: ", stringify!(int4), "::", stringify!(w))
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct uint4 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
    pub w: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uint4() {
    const UNINIT: ::std::mem::MaybeUninit<uint4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uint4>(),
        16usize,
        concat!("Size of: ", stringify!(uint4))
    );
    assert_eq!(
        ::std::mem::align_of::<uint4>(),
        16usize,
        concat!("Alignment of ", stringify!(uint4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uint4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(uint4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(uint4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        12usize,
        concat!("Offset of field: ", stringify!(uint4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long1 {
    pub x: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_long1() {
    const UNINIT: ::std::mem::MaybeUninit<long1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<long1>(),
        8usize,
        concat!("Size of: ", stringify!(long1))
    );
    assert_eq!(
        ::std::mem::align_of::<long1>(),
        8usize,
        concat!("Alignment of ", stringify!(long1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(long1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong1 {
    pub x: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong1() {
    const UNINIT: ::std::mem::MaybeUninit<ulong1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ulong1>(),
        8usize,
        concat!("Size of: ", stringify!(ulong1))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong1>(),
        8usize,
        concat!("Alignment of ", stringify!(ulong1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ulong1), "::", stringify!(x))
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct long2 {
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_long2() {
    const UNINIT: ::std::mem::MaybeUninit<long2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<long2>(),
        16usize,
        concat!("Size of: ", stringify!(long2))
    );
    assert_eq!(
        ::std::mem::align_of::<long2>(),
        16usize,
        concat!("Alignment of ", stringify!(long2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(long2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(long2), "::", stringify!(y))
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct ulong2 {
    pub x: ::std::os::raw::c_ulong,
    pub y: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong2() {
    const UNINIT: ::std::mem::MaybeUninit<ulong2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ulong2>(),
        16usize,
        concat!("Size of: ", stringify!(ulong2))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong2>(),
        16usize,
        concat!("Alignment of ", stringify!(ulong2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ulong2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ulong2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long3 {
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
    pub z: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_long3() {
    const UNINIT: ::std::mem::MaybeUninit<long3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<long3>(),
        24usize,
        concat!("Size of: ", stringify!(long3))
    );
    assert_eq!(
        ::std::mem::align_of::<long3>(),
        8usize,
        concat!("Alignment of ", stringify!(long3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(long3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(long3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(long3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong3 {
    pub x: ::std::os::raw::c_ulong,
    pub y: ::std::os::raw::c_ulong,
    pub z: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong3() {
    const UNINIT: ::std::mem::MaybeUninit<ulong3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ulong3>(),
        24usize,
        concat!("Size of: ", stringify!(ulong3))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong3>(),
        8usize,
        concat!("Alignment of ", stringify!(ulong3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ulong3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ulong3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ulong3), "::", stringify!(z))
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct long4 {
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
    pub z: ::std::os::raw::c_long,
    pub w: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_long4() {
    const UNINIT: ::std::mem::MaybeUninit<long4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<long4>(),
        32usize,
        concat!("Size of: ", stringify!(long4))
    );
    assert_eq!(
        ::std::mem::align_of::<long4>(),
        16usize,
        concat!("Alignment of ", stringify!(long4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(long4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(long4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(long4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(long4), "::", stringify!(w))
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct ulong4 {
    pub x: ::std::os::raw::c_ulong,
    pub y: ::std::os::raw::c_ulong,
    pub z: ::std::os::raw::c_ulong,
    pub w: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong4() {
    const UNINIT: ::std::mem::MaybeUninit<ulong4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ulong4>(),
        32usize,
        concat!("Size of: ", stringify!(ulong4))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong4>(),
        16usize,
        concat!("Alignment of ", stringify!(ulong4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float1 {
    pub x: f32,
}
#[test]
fn bindgen_test_layout_float1() {
    const UNINIT: ::std::mem::MaybeUninit<float1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<float1>(),
        4usize,
        concat!("Size of: ", stringify!(float1))
    );
    assert_eq!(
        ::std::mem::align_of::<float1>(),
        4usize,
        concat!("Alignment of ", stringify!(float1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float1), "::", stringify!(x))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct float2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_float2() {
    const UNINIT: ::std::mem::MaybeUninit<float2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<float2>(),
        8usize,
        concat!("Size of: ", stringify!(float2))
    );
    assert_eq!(
        ::std::mem::align_of::<float2>(),
        8usize,
        concat!("Alignment of ", stringify!(float2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(float2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_float3() {
    const UNINIT: ::std::mem::MaybeUninit<float3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<float3>(),
        12usize,
        concat!("Size of: ", stringify!(float3))
    );
    assert_eq!(
        ::std::mem::align_of::<float3>(),
        4usize,
        concat!("Alignment of ", stringify!(float3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(float3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(float3), "::", stringify!(z))
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct float4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_float4() {
    const UNINIT: ::std::mem::MaybeUninit<float4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<float4>(),
        16usize,
        concat!("Size of: ", stringify!(float4))
    );
    assert_eq!(
        ::std::mem::align_of::<float4>(),
        16usize,
        concat!("Alignment of ", stringify!(float4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(float4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(float4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        12usize,
        concat!("Offset of field: ", stringify!(float4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong1 {
    pub x: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong1() {
    const UNINIT: ::std::mem::MaybeUninit<longlong1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<longlong1>(),
        8usize,
        concat!("Size of: ", stringify!(longlong1))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong1>(),
        8usize,
        concat!("Alignment of ", stringify!(longlong1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong1),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong1 {
    pub x: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong1() {
    const UNINIT: ::std::mem::MaybeUninit<ulonglong1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ulonglong1>(),
        8usize,
        concat!("Size of: ", stringify!(ulonglong1))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong1>(),
        8usize,
        concat!("Alignment of ", stringify!(ulonglong1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong1),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct longlong2 {
    pub x: ::std::os::raw::c_longlong,
    pub y: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong2() {
    const UNINIT: ::std::mem::MaybeUninit<longlong2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<longlong2>(),
        16usize,
        concat!("Size of: ", stringify!(longlong2))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong2>(),
        16usize,
        concat!("Alignment of ", stringify!(longlong2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong2 {
    pub x: ::std::os::raw::c_ulonglong,
    pub y: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong2() {
    const UNINIT: ::std::mem::MaybeUninit<ulonglong2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ulonglong2>(),
        16usize,
        concat!("Size of: ", stringify!(ulonglong2))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong2>(),
        16usize,
        concat!("Alignment of ", stringify!(ulonglong2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong3 {
    pub x: ::std::os::raw::c_longlong,
    pub y: ::std::os::raw::c_longlong,
    pub z: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong3() {
    const UNINIT: ::std::mem::MaybeUninit<longlong3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<longlong3>(),
        24usize,
        concat!("Size of: ", stringify!(longlong3))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong3>(),
        8usize,
        concat!("Alignment of ", stringify!(longlong3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong3 {
    pub x: ::std::os::raw::c_ulonglong,
    pub y: ::std::os::raw::c_ulonglong,
    pub z: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong3() {
    const UNINIT: ::std::mem::MaybeUninit<ulonglong3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ulonglong3>(),
        24usize,
        concat!("Size of: ", stringify!(ulonglong3))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong3>(),
        8usize,
        concat!("Alignment of ", stringify!(ulonglong3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct longlong4 {
    pub x: ::std::os::raw::c_longlong,
    pub y: ::std::os::raw::c_longlong,
    pub z: ::std::os::raw::c_longlong,
    pub w: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong4() {
    const UNINIT: ::std::mem::MaybeUninit<longlong4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<longlong4>(),
        32usize,
        concat!("Size of: ", stringify!(longlong4))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong4>(),
        16usize,
        concat!("Alignment of ", stringify!(longlong4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong4),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong4 {
    pub x: ::std::os::raw::c_ulonglong,
    pub y: ::std::os::raw::c_ulonglong,
    pub z: ::std::os::raw::c_ulonglong,
    pub w: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong4() {
    const UNINIT: ::std::mem::MaybeUninit<ulonglong4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ulonglong4>(),
        32usize,
        concat!("Size of: ", stringify!(ulonglong4))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong4>(),
        16usize,
        concat!("Alignment of ", stringify!(ulonglong4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong4),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double1 {
    pub x: f64,
}
#[test]
fn bindgen_test_layout_double1() {
    const UNINIT: ::std::mem::MaybeUninit<double1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<double1>(),
        8usize,
        concat!("Size of: ", stringify!(double1))
    );
    assert_eq!(
        ::std::mem::align_of::<double1>(),
        8usize,
        concat!("Alignment of ", stringify!(double1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double1),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct double2 {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_double2() {
    const UNINIT: ::std::mem::MaybeUninit<double2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<double2>(),
        16usize,
        concat!("Size of: ", stringify!(double2))
    );
    assert_eq!(
        ::std::mem::align_of::<double2>(),
        16usize,
        concat!("Alignment of ", stringify!(double2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(double2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double3 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_double3() {
    const UNINIT: ::std::mem::MaybeUninit<double3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<double3>(),
        24usize,
        concat!("Size of: ", stringify!(double3))
    );
    assert_eq!(
        ::std::mem::align_of::<double3>(),
        8usize,
        concat!("Alignment of ", stringify!(double3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(double3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(double3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct double4 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_double4() {
    const UNINIT: ::std::mem::MaybeUninit<double4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<double4>(),
        32usize,
        concat!("Size of: ", stringify!(double4))
    );
    assert_eq!(
        ::std::mem::align_of::<double4>(),
        16usize,
        concat!("Alignment of ", stringify!(double4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(double4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(double4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(double4),
            "::",
            stringify!(w)
        )
    );
}
#[doc = "                                                                              *\n                                                                              *\n                                                                              *"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim3 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_dim3() {
    const UNINIT: ::std::mem::MaybeUninit<dim3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dim3>(),
        12usize,
        concat!("Size of: ", stringify!(dim3))
    );
    assert_eq!(
        ::std::mem::align_of::<dim3>(),
        4usize,
        concat!("Alignment of ", stringify!(dim3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(z))
    );
}
pub type cuFloatComplex = float2;
pub type cuDoubleComplex = double2;
pub type cuComplex = cuFloatComplex;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " The API call returned with no errors. In the case of query calls, this\n also means that the operation being queried is complete (see\n ::cudaEventQuery() and ::cudaStreamQuery())."]
pub const cudaError_cudaSuccess: cudaError = 0;
#[doc = " This indicates that one or more of the parameters passed to the API call\n is not within an acceptable range of values."]
pub const cudaError_cudaErrorInvalidValue: cudaError = 1;
#[doc = " The API call failed because it was unable to allocate enough memory to\n perform the requested operation."]
pub const cudaError_cudaErrorMemoryAllocation: cudaError = 2;
#[doc = " The API call failed because the CUDA driver and runtime could not be\n initialized."]
pub const cudaError_cudaErrorInitializationError: cudaError = 3;
#[doc = " This indicates that a CUDA Runtime API call cannot be executed because\n it is being called during process shut down, at a point in time after\n CUDA driver has been unloaded."]
pub const cudaError_cudaErrorCudartUnloading: cudaError = 4;
#[doc = " This indicates profiler is not initialized for this run. This can\n happen when the application is running with external profiling tools\n like visual profiler."]
pub const cudaError_cudaErrorProfilerDisabled: cudaError = 5;
#[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to attempt to enable/disable the profiling via ::cudaProfilerStart or\n ::cudaProfilerStop without initialization."]
pub const cudaError_cudaErrorProfilerNotInitialized: cudaError = 6;
#[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to call cudaProfilerStart() when profiling is already enabled."]
pub const cudaError_cudaErrorProfilerAlreadyStarted: cudaError = 7;
#[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to call cudaProfilerStop() when profiling is already disabled."]
pub const cudaError_cudaErrorProfilerAlreadyStopped: cudaError = 8;
#[doc = " This indicates that a kernel launch is requesting resources that can\n never be satisfied by the current device. Requesting more shared memory\n per block than the device supports will trigger this error, as will\n requesting too many threads or blocks. See ::cudaDeviceProp for more\n device limitations."]
pub const cudaError_cudaErrorInvalidConfiguration: cudaError = 9;
#[doc = " This indicates that one or more of the pitch-related parameters passed\n to the API call is not within the acceptable range for pitch."]
pub const cudaError_cudaErrorInvalidPitchValue: cudaError = 12;
#[doc = " This indicates that the symbol name/identifier passed to the API call\n is not a valid name or identifier."]
pub const cudaError_cudaErrorInvalidSymbol: cudaError = 13;
#[doc = " This indicates that at least one host pointer passed to the API call is\n not a valid host pointer.\n \\deprecated\n This error return is deprecated as of CUDA 10.1."]
pub const cudaError_cudaErrorInvalidHostPointer: cudaError = 16;
#[doc = " This indicates that at least one device pointer passed to the API call is\n not a valid device pointer.\n \\deprecated\n This error return is deprecated as of CUDA 10.1."]
pub const cudaError_cudaErrorInvalidDevicePointer: cudaError = 17;
#[doc = " This indicates that the texture passed to the API call is not a valid\n texture."]
pub const cudaError_cudaErrorInvalidTexture: cudaError = 18;
#[doc = " This indicates that the texture binding is not valid. This occurs if you\n call ::cudaGetTextureAlignmentOffset() with an unbound texture."]
pub const cudaError_cudaErrorInvalidTextureBinding: cudaError = 19;
#[doc = " This indicates that the channel descriptor passed to the API call is not\n valid. This occurs if the format is not one of the formats specified by\n ::cudaChannelFormatKind, or if one of the dimensions is invalid."]
pub const cudaError_cudaErrorInvalidChannelDescriptor: cudaError = 20;
#[doc = " This indicates that the direction of the memcpy passed to the API call is\n not one of the types specified by ::cudaMemcpyKind."]
pub const cudaError_cudaErrorInvalidMemcpyDirection: cudaError = 21;
#[doc = " This indicated that the user has taken the address of a constant variable,\n which was forbidden up until the CUDA 3.1 release.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Variables in constant\n memory may now have their address taken by the runtime via\n ::cudaGetSymbolAddress()."]
pub const cudaError_cudaErrorAddressOfConstant: cudaError = 22;
#[doc = " This indicated that a texture fetch was not able to be performed.\n This was previously used for device emulation of texture operations.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorTextureFetchFailed: cudaError = 23;
#[doc = " This indicated that a texture was not bound for access.\n This was previously used for device emulation of texture operations.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorTextureNotBound: cudaError = 24;
#[doc = " This indicated that a synchronization operation had failed.\n This was previously used for some device emulation functions.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorSynchronizationError: cudaError = 25;
#[doc = " This indicates that a non-float texture was being accessed with linear\n filtering. This is not supported by CUDA."]
pub const cudaError_cudaErrorInvalidFilterSetting: cudaError = 26;
#[doc = " This indicates that an attempt was made to read a non-float texture as a\n normalized float. This is not supported by CUDA."]
pub const cudaError_cudaErrorInvalidNormSetting: cudaError = 27;
#[doc = " Mixing of device and device emulation code was not allowed.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorMixedDeviceExecution: cudaError = 28;
#[doc = " This indicates that the API call is not yet implemented. Production\n releases of CUDA will never return this error.\n \\deprecated\n This error return is deprecated as of CUDA 4.1."]
pub const cudaError_cudaErrorNotYetImplemented: cudaError = 31;
#[doc = " This indicated that an emulated device pointer exceeded the 32-bit address\n range.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorMemoryValueTooLarge: cudaError = 32;
#[doc = " This indicates that the CUDA driver that the application has loaded is a\n stub library. Applications that run with the stub rather than a real\n driver loaded will result in CUDA API returning this error."]
pub const cudaError_cudaErrorStubLibrary: cudaError = 34;
#[doc = " This indicates that the installed NVIDIA CUDA driver is older than the\n CUDA runtime library. This is not a supported configuration. Users should\n install an updated NVIDIA display driver to allow the application to run."]
pub const cudaError_cudaErrorInsufficientDriver: cudaError = 35;
#[doc = " This indicates that the API call requires a newer CUDA driver than the one\n currently installed. Users should install an updated NVIDIA CUDA driver\n to allow the API call to succeed."]
pub const cudaError_cudaErrorCallRequiresNewerDriver: cudaError = 36;
#[doc = " This indicates that the surface passed to the API call is not a valid\n surface."]
pub const cudaError_cudaErrorInvalidSurface: cudaError = 37;
#[doc = " This indicates that multiple global or constant variables (across separate\n CUDA source files in the application) share the same string name."]
pub const cudaError_cudaErrorDuplicateVariableName: cudaError = 43;
#[doc = " This indicates that multiple textures (across separate CUDA source\n files in the application) share the same string name."]
pub const cudaError_cudaErrorDuplicateTextureName: cudaError = 44;
#[doc = " This indicates that multiple surfaces (across separate CUDA source\n files in the application) share the same string name."]
pub const cudaError_cudaErrorDuplicateSurfaceName: cudaError = 45;
#[doc = " This indicates that all CUDA devices are busy or unavailable at the current\n time. Devices are often busy/unavailable due to use of\n ::cudaComputeModeExclusive, ::cudaComputeModeProhibited or when long\n running CUDA kernels have filled up the GPU and are blocking new work\n from starting. They can also be unavailable due to memory constraints\n on a device that already has active CUDA work being performed."]
pub const cudaError_cudaErrorDevicesUnavailable: cudaError = 46;
#[doc = " This indicates that the current context is not compatible with this\n the CUDA Runtime. This can only occur if you are using CUDA\n Runtime/Driver interoperability and have created an existing Driver\n context using the driver API. The Driver context may be incompatible\n either because the Driver context was created using an older version\n of the API, because the Runtime API call expects a primary driver\n context and the Driver context is not primary, or because the Driver\n context has been destroyed. Please see \\ref CUDART_DRIVER \"Interactions\n with the CUDA Driver API\" for more information."]
pub const cudaError_cudaErrorIncompatibleDriverContext: cudaError = 49;
#[doc = " The device function being invoked (usually via ::cudaLaunchKernel()) was not\n previously configured via the ::cudaConfigureCall() function."]
pub const cudaError_cudaErrorMissingConfiguration: cudaError = 52;
#[doc = " This indicated that a previous kernel launch failed. This was previously\n used for device emulation of kernel launches.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorPriorLaunchFailure: cudaError = 53;
#[doc = " This error indicates that a device runtime grid launch did not occur\n because the depth of the child grid would exceed the maximum supported\n number of nested grid launches."]
pub const cudaError_cudaErrorLaunchMaxDepthExceeded: cudaError = 65;
#[doc = " This error indicates that a grid launch did not occur because the kernel\n uses file-scoped textures which are unsupported by the device runtime.\n Kernels launched via the device runtime only support textures created with\n the Texture Object API's."]
pub const cudaError_cudaErrorLaunchFileScopedTex: cudaError = 66;
#[doc = " This error indicates that a grid launch did not occur because the kernel\n uses file-scoped surfaces which are unsupported by the device runtime.\n Kernels launched via the device runtime only support surfaces created with\n the Surface Object API's."]
pub const cudaError_cudaErrorLaunchFileScopedSurf: cudaError = 67;
#[doc = " This error indicates that a call to ::cudaDeviceSynchronize made from\n the device runtime failed because the call was made at grid depth greater\n than than either the default (2 levels of grids) or user specified device\n limit ::cudaLimitDevRuntimeSyncDepth. To be able to synchronize on\n launched grids at a greater depth successfully, the maximum nested\n depth at which ::cudaDeviceSynchronize will be called must be specified\n with the ::cudaLimitDevRuntimeSyncDepth limit to the ::cudaDeviceSetLimit\n api before the host-side launch of a kernel using the device runtime.\n Keep in mind that additional levels of sync depth require the runtime\n to reserve large amounts of device memory that cannot be used for\n user allocations."]
pub const cudaError_cudaErrorSyncDepthExceeded: cudaError = 68;
#[doc = " This error indicates that a device runtime grid launch failed because\n the launch would exceed the limit ::cudaLimitDevRuntimePendingLaunchCount.\n For this launch to proceed successfully, ::cudaDeviceSetLimit must be\n called to set the ::cudaLimitDevRuntimePendingLaunchCount to be higher\n than the upper bound of outstanding launches that can be issued to the\n device runtime. Keep in mind that raising the limit of pending device\n runtime launches will require the runtime to reserve device memory that\n cannot be used for user allocations."]
pub const cudaError_cudaErrorLaunchPendingCountExceeded: cudaError = 69;
#[doc = " The requested device function does not exist or is not compiled for the\n proper device architecture."]
pub const cudaError_cudaErrorInvalidDeviceFunction: cudaError = 98;
#[doc = " This indicates that no CUDA-capable devices were detected by the installed\n CUDA driver."]
pub const cudaError_cudaErrorNoDevice: cudaError = 100;
#[doc = " This indicates that the device ordinal supplied by the user does not\n correspond to a valid CUDA device or that the action requested is\n invalid for the specified device."]
pub const cudaError_cudaErrorInvalidDevice: cudaError = 101;
#[doc = " This indicates that the device doesn't have a valid Grid License."]
pub const cudaError_cudaErrorDeviceNotLicensed: cudaError = 102;
#[doc = " By default, the CUDA runtime may perform a minimal set of self-tests,\n as well as CUDA driver tests, to establish the validity of both.\n Introduced in CUDA 11.2, this error return indicates that at least one\n of these tests has failed and the validity of either the runtime\n or the driver could not be established."]
pub const cudaError_cudaErrorSoftwareValidityNotEstablished: cudaError = 103;
#[doc = " This indicates an internal startup failure in the CUDA runtime."]
pub const cudaError_cudaErrorStartupFailure: cudaError = 127;
#[doc = " This indicates that the device kernel image is invalid."]
pub const cudaError_cudaErrorInvalidKernelImage: cudaError = 200;
#[doc = " This most frequently indicates that there is no context bound to the\n current thread. This can also be returned if the context passed to an\n API call is not a valid handle (such as a context that has had\n ::cuCtxDestroy() invoked on it). This can also be returned if a user\n mixes different API versions (i.e. 3010 context with 3020 API calls).\n See ::cuCtxGetApiVersion() for more details."]
pub const cudaError_cudaErrorDeviceUninitialized: cudaError = 201;
#[doc = " This indicates that the buffer object could not be mapped."]
pub const cudaError_cudaErrorMapBufferObjectFailed: cudaError = 205;
#[doc = " This indicates that the buffer object could not be unmapped."]
pub const cudaError_cudaErrorUnmapBufferObjectFailed: cudaError = 206;
#[doc = " This indicates that the specified array is currently mapped and thus\n cannot be destroyed."]
pub const cudaError_cudaErrorArrayIsMapped: cudaError = 207;
#[doc = " This indicates that the resource is already mapped."]
pub const cudaError_cudaErrorAlreadyMapped: cudaError = 208;
#[doc = " This indicates that there is no kernel image available that is suitable\n for the device. This can occur when a user specifies code generation\n options for a particular CUDA source file that do not include the\n corresponding device configuration."]
pub const cudaError_cudaErrorNoKernelImageForDevice: cudaError = 209;
#[doc = " This indicates that a resource has already been acquired."]
pub const cudaError_cudaErrorAlreadyAcquired: cudaError = 210;
#[doc = " This indicates that a resource is not mapped."]
pub const cudaError_cudaErrorNotMapped: cudaError = 211;
#[doc = " This indicates that a mapped resource is not available for access as an\n array."]
pub const cudaError_cudaErrorNotMappedAsArray: cudaError = 212;
#[doc = " This indicates that a mapped resource is not available for access as a\n pointer."]
pub const cudaError_cudaErrorNotMappedAsPointer: cudaError = 213;
#[doc = " This indicates that an uncorrectable ECC error was detected during\n execution."]
pub const cudaError_cudaErrorECCUncorrectable: cudaError = 214;
#[doc = " This indicates that the ::cudaLimit passed to the API call is not\n supported by the active device."]
pub const cudaError_cudaErrorUnsupportedLimit: cudaError = 215;
#[doc = " This indicates that a call tried to access an exclusive-thread device that\n is already in use by a different thread."]
pub const cudaError_cudaErrorDeviceAlreadyInUse: cudaError = 216;
#[doc = " This error indicates that P2P access is not supported across the given\n devices."]
pub const cudaError_cudaErrorPeerAccessUnsupported: cudaError = 217;
#[doc = " A PTX compilation failed. The runtime may fall back to compiling PTX if\n an application does not contain a suitable binary for the current device."]
pub const cudaError_cudaErrorInvalidPtx: cudaError = 218;
#[doc = " This indicates an error with the OpenGL or DirectX context."]
pub const cudaError_cudaErrorInvalidGraphicsContext: cudaError = 219;
#[doc = " This indicates that an uncorrectable NVLink error was detected during the\n execution."]
pub const cudaError_cudaErrorNvlinkUncorrectable: cudaError = 220;
#[doc = " This indicates that the PTX JIT compiler library was not found. The JIT Compiler\n library is used for PTX compilation. The runtime may fall back to compiling PTX\n if an application does not contain a suitable binary for the current device."]
pub const cudaError_cudaErrorJitCompilerNotFound: cudaError = 221;
#[doc = " This indicates that the provided PTX was compiled with an unsupported toolchain.\n The most common reason for this, is the PTX was generated by a compiler newer\n than what is supported by the CUDA driver and PTX JIT compiler."]
pub const cudaError_cudaErrorUnsupportedPtxVersion: cudaError = 222;
#[doc = " This indicates that the JIT compilation was disabled. The JIT compilation compiles\n PTX. The runtime may fall back to compiling PTX if an application does not contain\n a suitable binary for the current device."]
pub const cudaError_cudaErrorJitCompilationDisabled: cudaError = 223;
#[doc = " This indicates that the provided execution affinity is not supported by the device."]
pub const cudaError_cudaErrorUnsupportedExecAffinity: cudaError = 224;
#[doc = " This indicates that the device kernel source is invalid."]
pub const cudaError_cudaErrorInvalidSource: cudaError = 300;
#[doc = " This indicates that the file specified was not found."]
pub const cudaError_cudaErrorFileNotFound: cudaError = 301;
#[doc = " This indicates that a link to a shared object failed to resolve."]
pub const cudaError_cudaErrorSharedObjectSymbolNotFound: cudaError = 302;
#[doc = " This indicates that initialization of a shared object failed."]
pub const cudaError_cudaErrorSharedObjectInitFailed: cudaError = 303;
#[doc = " This error indicates that an OS call failed."]
pub const cudaError_cudaErrorOperatingSystem: cudaError = 304;
#[doc = " This indicates that a resource handle passed to the API call was not\n valid. Resource handles are opaque types like ::cudaStream_t and\n ::cudaEvent_t."]
pub const cudaError_cudaErrorInvalidResourceHandle: cudaError = 400;
#[doc = " This indicates that a resource required by the API call is not in a\n valid state to perform the requested operation."]
pub const cudaError_cudaErrorIllegalState: cudaError = 401;
#[doc = " This indicates that a named symbol was not found. Examples of symbols\n are global/constant variable names, driver function names, texture names,\n and surface names."]
pub const cudaError_cudaErrorSymbolNotFound: cudaError = 500;
#[doc = " This indicates that asynchronous operations issued previously have not\n completed yet. This result is not actually an error, but must be indicated\n differently than ::cudaSuccess (which indicates completion). Calls that\n may return this value include ::cudaEventQuery() and ::cudaStreamQuery()."]
pub const cudaError_cudaErrorNotReady: cudaError = 600;
#[doc = " The device encountered a load or store instruction on an invalid memory address.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorIllegalAddress: cudaError = 700;
#[doc = " This indicates that a launch did not occur because it did not have\n appropriate resources. Although this error is similar to\n ::cudaErrorInvalidConfiguration, this error usually indicates that the\n user has attempted to pass too many arguments to the device kernel, or the\n kernel launch specifies too many threads for the kernel's register count."]
pub const cudaError_cudaErrorLaunchOutOfResources: cudaError = 701;
#[doc = " This indicates that the device kernel took too long to execute. This can\n only occur if timeouts are enabled - see the device property\n \\ref ::cudaDeviceProp::kernelExecTimeoutEnabled \"kernelExecTimeoutEnabled\"\n for more information.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorLaunchTimeout: cudaError = 702;
#[doc = " This error indicates a kernel launch that uses an incompatible texturing\n mode."]
pub const cudaError_cudaErrorLaunchIncompatibleTexturing: cudaError = 703;
#[doc = " This error indicates that a call to ::cudaDeviceEnablePeerAccess() is\n trying to re-enable peer addressing on from a context which has already\n had peer addressing enabled."]
pub const cudaError_cudaErrorPeerAccessAlreadyEnabled: cudaError = 704;
#[doc = " This error indicates that ::cudaDeviceDisablePeerAccess() is trying to\n disable peer addressing which has not been enabled yet via\n ::cudaDeviceEnablePeerAccess()."]
pub const cudaError_cudaErrorPeerAccessNotEnabled: cudaError = 705;
#[doc = " This indicates that the user has called ::cudaSetValidDevices(),\n ::cudaSetDeviceFlags(), ::cudaD3D9SetDirect3DDevice(),\n ::cudaD3D10SetDirect3DDevice, ::cudaD3D11SetDirect3DDevice(), or\n ::cudaVDPAUSetVDPAUDevice() after initializing the CUDA runtime by\n calling non-device management operations (allocating memory and\n launching kernels are examples of non-device management operations).\n This error can also be returned if using runtime/driver\n interoperability and there is an existing ::CUcontext active on the\n host thread."]
pub const cudaError_cudaErrorSetOnActiveProcess: cudaError = 708;
#[doc = " This error indicates that the context current to the calling thread\n has been destroyed using ::cuCtxDestroy, or is a primary context which\n has not yet been initialized."]
pub const cudaError_cudaErrorContextIsDestroyed: cudaError = 709;
#[doc = " An assert triggered in device code during kernel execution. The device\n cannot be used again. All existing allocations are invalid. To continue\n using CUDA, the process must be terminated and relaunched."]
pub const cudaError_cudaErrorAssert: cudaError = 710;
#[doc = " This error indicates that the hardware resources required to enable\n peer access have been exhausted for one or more of the devices\n passed to ::cudaEnablePeerAccess()."]
pub const cudaError_cudaErrorTooManyPeers: cudaError = 711;
#[doc = " This error indicates that the memory range passed to ::cudaHostRegister()\n has already been registered."]
pub const cudaError_cudaErrorHostMemoryAlreadyRegistered: cudaError = 712;
#[doc = " This error indicates that the pointer passed to ::cudaHostUnregister()\n does not correspond to any currently registered memory region."]
pub const cudaError_cudaErrorHostMemoryNotRegistered: cudaError = 713;
#[doc = " Device encountered an error in the call stack during kernel execution,\n possibly due to stack corruption or exceeding the stack size limit.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorHardwareStackError: cudaError = 714;
#[doc = " The device encountered an illegal instruction during kernel execution\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorIllegalInstruction: cudaError = 715;
#[doc = " The device encountered a load or store instruction\n on a memory address which is not aligned.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorMisalignedAddress: cudaError = 716;
#[doc = " While executing a kernel, the device encountered an instruction\n which can only operate on memory locations in certain address spaces\n (global, shared, or local), but was supplied a memory address not\n belonging to an allowed address space.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorInvalidAddressSpace: cudaError = 717;
#[doc = " The device encountered an invalid program counter.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorInvalidPc: cudaError = 718;
#[doc = " An exception occurred on the device while executing a kernel. Common\n causes include dereferencing an invalid device pointer and accessing\n out of bounds shared memory. Less common cases can be system specific - more\n information about these cases can be found in the system specific user guide.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorLaunchFailure: cudaError = 719;
#[doc = " This error indicates that the number of blocks launched per grid for a kernel that was\n launched via either ::cudaLaunchCooperativeKernel or ::cudaLaunchCooperativeKernelMultiDevice\n exceeds the maximum number of blocks as allowed by ::cudaOccupancyMaxActiveBlocksPerMultiprocessor\n or ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags times the number of multiprocessors\n as specified by the device attribute ::cudaDevAttrMultiProcessorCount."]
pub const cudaError_cudaErrorCooperativeLaunchTooLarge: cudaError = 720;
#[doc = " This error indicates the attempted operation is not permitted."]
pub const cudaError_cudaErrorNotPermitted: cudaError = 800;
#[doc = " This error indicates the attempted operation is not supported\n on the current system or device."]
pub const cudaError_cudaErrorNotSupported: cudaError = 801;
#[doc = " This error indicates that the system is not yet ready to start any CUDA\n work.  To continue using CUDA, verify the system configuration is in a\n valid state and all required driver daemons are actively running.\n More information about this error can be found in the system specific\n user guide."]
pub const cudaError_cudaErrorSystemNotReady: cudaError = 802;
#[doc = " This error indicates that there is a mismatch between the versions of\n the display driver and the CUDA driver. Refer to the compatibility documentation\n for supported versions."]
pub const cudaError_cudaErrorSystemDriverMismatch: cudaError = 803;
#[doc = " This error indicates that the system was upgraded to run with forward compatibility\n but the visible hardware detected by CUDA does not support this configuration.\n Refer to the compatibility documentation for the supported hardware matrix or ensure\n that only supported hardware is visible during initialization via the CUDA_VISIBLE_DEVICES\n environment variable."]
pub const cudaError_cudaErrorCompatNotSupportedOnDevice: cudaError = 804;
#[doc = " This error indicates that the MPS client failed to connect to the MPS control daemon or the MPS server."]
pub const cudaError_cudaErrorMpsConnectionFailed: cudaError = 805;
#[doc = " This error indicates that the remote procedural call between the MPS server and the MPS client failed."]
pub const cudaError_cudaErrorMpsRpcFailure: cudaError = 806;
#[doc = " This error indicates that the MPS server is not ready to accept new MPS client requests.\n This error can be returned when the MPS server is in the process of recovering from a fatal failure."]
pub const cudaError_cudaErrorMpsServerNotReady: cudaError = 807;
#[doc = " This error indicates that the hardware resources required to create MPS client have been exhausted."]
pub const cudaError_cudaErrorMpsMaxClientsReached: cudaError = 808;
#[doc = " This error indicates the the hardware resources required to device connections have been exhausted."]
pub const cudaError_cudaErrorMpsMaxConnectionsReached: cudaError = 809;
#[doc = " The operation is not permitted when the stream is capturing."]
pub const cudaError_cudaErrorStreamCaptureUnsupported: cudaError = 900;
#[doc = " The current capture sequence on the stream has been invalidated due to\n a previous error."]
pub const cudaError_cudaErrorStreamCaptureInvalidated: cudaError = 901;
#[doc = " The operation would have resulted in a merge of two independent capture\n sequences."]
pub const cudaError_cudaErrorStreamCaptureMerge: cudaError = 902;
#[doc = " The capture was not initiated in this stream."]
pub const cudaError_cudaErrorStreamCaptureUnmatched: cudaError = 903;
#[doc = " The capture sequence contains a fork that was not joined to the primary\n stream."]
pub const cudaError_cudaErrorStreamCaptureUnjoined: cudaError = 904;
#[doc = " A dependency would have been created which crosses the capture sequence\n boundary. Only implicit in-stream ordering dependencies are allowed to\n cross the boundary."]
pub const cudaError_cudaErrorStreamCaptureIsolation: cudaError = 905;
#[doc = " The operation would have resulted in a disallowed implicit dependency on\n a current capture sequence from cudaStreamLegacy."]
pub const cudaError_cudaErrorStreamCaptureImplicit: cudaError = 906;
#[doc = " The operation is not permitted on an event which was last recorded in a\n capturing stream."]
pub const cudaError_cudaErrorCapturedEvent: cudaError = 907;
#[doc = " A stream capture sequence not initiated with the ::cudaStreamCaptureModeRelaxed\n argument to ::cudaStreamBeginCapture was passed to ::cudaStreamEndCapture in a\n different thread."]
pub const cudaError_cudaErrorStreamCaptureWrongThread: cudaError = 908;
#[doc = " This indicates that the wait operation has timed out."]
pub const cudaError_cudaErrorTimeout: cudaError = 909;
#[doc = " This error indicates that the graph update was not performed because it included\n changes which violated constraints specific to instantiated graph update."]
pub const cudaError_cudaErrorGraphExecUpdateFailure: cudaError = 910;
#[doc = " This indicates that an async error has occurred in a device outside of CUDA.\n If CUDA was waiting for an external device's signal before consuming shared data,\n the external device signaled an error indicating that the data is not valid for\n consumption. This leaves the process in an inconsistent state and any further CUDA\n work will return the same error. To continue using CUDA, the process must be\n terminated and relaunched."]
pub const cudaError_cudaErrorExternalDevice: cudaError = 911;
#[doc = " This indicates that an unknown internal error has occurred."]
pub const cudaError_cudaErrorUnknown: cudaError = 999;
#[doc = " Any unhandled CUDA driver error is added to this value and returned via\n the runtime. Production releases of CUDA should not return such errors.\n \\deprecated\n This error return is deprecated as of CUDA 4.1."]
pub const cudaError_cudaErrorApiFailureBase: cudaError = 10000;
#[doc = " CUDA error types"]
pub type cudaError = ::std::os::raw::c_uint;
#[doc = "< Signed channel format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindSigned: cudaChannelFormatKind = 0;
#[doc = "< Unsigned channel format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsigned: cudaChannelFormatKind = 1;
#[doc = "< Float channel format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindFloat: cudaChannelFormatKind = 2;
#[doc = "< No channel format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindNone: cudaChannelFormatKind = 3;
pub const cudaChannelFormatKind_cudaChannelFormatKindNV12: cudaChannelFormatKind = 4;
#[doc = " Channel format kind"]
pub type cudaChannelFormatKind = ::std::os::raw::c_uint;
#[doc = " CUDA Channel format descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaChannelFormatDesc {
    #[doc = "< x"]
    pub x: ::std::os::raw::c_int,
    #[doc = "< y"]
    pub y: ::std::os::raw::c_int,
    #[doc = "< z"]
    pub z: ::std::os::raw::c_int,
    #[doc = "< w"]
    pub w: ::std::os::raw::c_int,
    #[doc = "< Channel format kind"]
    pub f: cudaChannelFormatKind,
}
#[test]
fn bindgen_test_layout_cudaChannelFormatDesc() {
    const UNINIT: ::std::mem::MaybeUninit<cudaChannelFormatDesc> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaChannelFormatDesc>(),
        20usize,
        concat!("Size of: ", stringify!(cudaChannelFormatDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaChannelFormatDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaChannelFormatDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArray {
    _unused: [u8; 0],
}
#[doc = " CUDA array"]
pub type cudaArray_t = *mut cudaArray;
#[doc = " CUDA array (as source copy argument)"]
pub type cudaArray_const_t = *const cudaArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMipmappedArray {
    _unused: [u8; 0],
}
#[doc = " CUDA mipmapped array"]
pub type cudaMipmappedArray_t = *mut cudaMipmappedArray;
#[doc = " CUDA mipmapped array (as source argument)"]
pub type cudaMipmappedArray_const_t = *const cudaMipmappedArray;
#[doc = " Sparse CUDA array and CUDA mipmapped array properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArraySparseProperties {
    pub tileExtent: cudaArraySparseProperties__bindgen_ty_1,
    #[doc = "< First mip level at which the mip tail begins"]
    pub miptailFirstLevel: ::std::os::raw::c_uint,
    #[doc = "< Total size of the mip tail."]
    pub miptailSize: ::std::os::raw::c_ulonglong,
    #[doc = "< Flags will either be zero or ::cudaArraySparsePropertiesSingleMipTail"]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArraySparseProperties__bindgen_ty_1 {
    #[doc = "< Tile width in elements"]
    pub width: ::std::os::raw::c_uint,
    #[doc = "< Tile height in elements"]
    pub height: ::std::os::raw::c_uint,
    #[doc = "< Tile depth in elements"]
    pub depth: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaArraySparseProperties__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<cudaArraySparseProperties__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaArraySparseProperties__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaArraySparseProperties__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1),
            "::",
            stringify!(depth)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaArraySparseProperties() {
    const UNINIT: ::std::mem::MaybeUninit<cudaArraySparseProperties> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaArraySparseProperties>(),
        48usize,
        concat!("Size of: ", stringify!(cudaArraySparseProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaArraySparseProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaArraySparseProperties))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tileExtent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties),
            "::",
            stringify!(tileExtent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).miptailFirstLevel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties),
            "::",
            stringify!(miptailFirstLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).miptailSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties),
            "::",
            stringify!(miptailSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = "< Unregistered memory"]
pub const cudaMemoryType_cudaMemoryTypeUnregistered: cudaMemoryType = 0;
#[doc = "< Host memory"]
pub const cudaMemoryType_cudaMemoryTypeHost: cudaMemoryType = 1;
#[doc = "< Device memory"]
pub const cudaMemoryType_cudaMemoryTypeDevice: cudaMemoryType = 2;
#[doc = "< Managed memory"]
pub const cudaMemoryType_cudaMemoryTypeManaged: cudaMemoryType = 3;
#[doc = " CUDA memory types"]
pub type cudaMemoryType = ::std::os::raw::c_uint;
#[doc = "< Host   -> Host"]
pub const cudaMemcpyKind_cudaMemcpyHostToHost: cudaMemcpyKind = 0;
#[doc = "< Host   -> Device"]
pub const cudaMemcpyKind_cudaMemcpyHostToDevice: cudaMemcpyKind = 1;
#[doc = "< Device -> Host"]
pub const cudaMemcpyKind_cudaMemcpyDeviceToHost: cudaMemcpyKind = 2;
#[doc = "< Device -> Device"]
pub const cudaMemcpyKind_cudaMemcpyDeviceToDevice: cudaMemcpyKind = 3;
#[doc = "< Direction of the transfer is inferred from the pointer values. Requires unified virtual addressing"]
pub const cudaMemcpyKind_cudaMemcpyDefault: cudaMemcpyKind = 4;
#[doc = " CUDA memory copy types"]
pub type cudaMemcpyKind = ::std::os::raw::c_uint;
#[doc = " CUDA Pitched memory pointer\n\n \\sa ::make_cudaPitchedPtr"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPitchedPtr {
    #[doc = "< Pointer to allocated memory"]
    pub ptr: *mut ::std::os::raw::c_void,
    #[doc = "< Pitch of allocated memory in bytes"]
    pub pitch: usize,
    #[doc = "< Logical width of allocation in elements"]
    pub xsize: usize,
    #[doc = "< Logical height of allocation in elements"]
    pub ysize: usize,
}
#[test]
fn bindgen_test_layout_cudaPitchedPtr() {
    const UNINIT: ::std::mem::MaybeUninit<cudaPitchedPtr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaPitchedPtr>(),
        32usize,
        concat!("Size of: ", stringify!(cudaPitchedPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPitchedPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPitchedPtr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPitchedPtr),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPitchedPtr),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xsize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPitchedPtr),
            "::",
            stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ysize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPitchedPtr),
            "::",
            stringify!(ysize)
        )
    );
}
#[doc = " CUDA extent\n\n \\sa ::make_cudaExtent"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExtent {
    #[doc = "< Width in elements when referring to array memory, in bytes when referring to linear memory"]
    pub width: usize,
    #[doc = "< Height in elements"]
    pub height: usize,
    #[doc = "< Depth in elements"]
    pub depth: usize,
}
#[test]
fn bindgen_test_layout_cudaExtent() {
    const UNINIT: ::std::mem::MaybeUninit<cudaExtent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExtent>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExtent))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExtent>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExtent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExtent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExtent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExtent),
            "::",
            stringify!(depth)
        )
    );
}
#[doc = " CUDA 3D position\n\n \\sa ::make_cudaPos"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPos {
    #[doc = "< x"]
    pub x: usize,
    #[doc = "< y"]
    pub y: usize,
    #[doc = "< z"]
    pub z: usize,
}
#[test]
fn bindgen_test_layout_cudaPos() {
    const UNINIT: ::std::mem::MaybeUninit<cudaPos> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaPos>(),
        24usize,
        concat!("Size of: ", stringify!(cudaPos))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPos>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPos))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPos),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPos),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPos),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " CUDA 3D memory copying parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemcpy3DParms {
    #[doc = "< Source memory address"]
    pub srcArray: cudaArray_t,
    #[doc = "< Source position offset"]
    pub srcPos: cudaPos,
    #[doc = "< Pitched source memory address"]
    pub srcPtr: cudaPitchedPtr,
    #[doc = "< Destination memory address"]
    pub dstArray: cudaArray_t,
    #[doc = "< Destination position offset"]
    pub dstPos: cudaPos,
    #[doc = "< Pitched destination memory address"]
    pub dstPtr: cudaPitchedPtr,
    #[doc = "< Requested memory copy size"]
    pub extent: cudaExtent,
    #[doc = "< Type of transfer"]
    pub kind: cudaMemcpyKind,
}
#[test]
fn bindgen_test_layout_cudaMemcpy3DParms() {
    const UNINIT: ::std::mem::MaybeUninit<cudaMemcpy3DParms> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaMemcpy3DParms>(),
        160usize,
        concat!("Size of: ", stringify!(cudaMemcpy3DParms))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemcpy3DParms>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemcpy3DParms))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcPos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(srcPos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcPtr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(srcPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstPos) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(dstPos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstPtr) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(dstPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(kind)
        )
    );
}
#[doc = " CUDA 3D cross-device memory copying parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemcpy3DPeerParms {
    #[doc = "< Source memory address"]
    pub srcArray: cudaArray_t,
    #[doc = "< Source position offset"]
    pub srcPos: cudaPos,
    #[doc = "< Pitched source memory address"]
    pub srcPtr: cudaPitchedPtr,
    #[doc = "< Source device"]
    pub srcDevice: ::std::os::raw::c_int,
    #[doc = "< Destination memory address"]
    pub dstArray: cudaArray_t,
    #[doc = "< Destination position offset"]
    pub dstPos: cudaPos,
    #[doc = "< Pitched destination memory address"]
    pub dstPtr: cudaPitchedPtr,
    #[doc = "< Destination device"]
    pub dstDevice: ::std::os::raw::c_int,
    #[doc = "< Requested memory copy size"]
    pub extent: cudaExtent,
}
#[test]
fn bindgen_test_layout_cudaMemcpy3DPeerParms() {
    const UNINIT: ::std::mem::MaybeUninit<cudaMemcpy3DPeerParms> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaMemcpy3DPeerParms>(),
        168usize,
        concat!("Size of: ", stringify!(cudaMemcpy3DPeerParms))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemcpy3DPeerParms>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemcpy3DPeerParms))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcPos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(srcPos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcPtr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(srcPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstPos) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(dstPos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstPtr) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(dstPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(extent)
        )
    );
}
#[doc = " CUDA Memset node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemsetParams {
    #[doc = "< Destination device pointer"]
    pub dst: *mut ::std::os::raw::c_void,
    #[doc = "< Pitch of destination device pointer. Unused if height is 1"]
    pub pitch: usize,
    #[doc = "< Value to be set"]
    pub value: ::std::os::raw::c_uint,
    #[doc = "< Size of each element in bytes. Must be 1, 2, or 4."]
    pub elementSize: ::std::os::raw::c_uint,
    #[doc = "< Width of the row in elements"]
    pub width: usize,
    #[doc = "< Number of rows"]
    pub height: usize,
}
#[test]
fn bindgen_test_layout_cudaMemsetParams() {
    const UNINIT: ::std::mem::MaybeUninit<cudaMemsetParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaMemsetParams>(),
        40usize,
        concat!("Size of: ", stringify!(cudaMemsetParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemsetParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemsetParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elementSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(elementSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(height)
        )
    );
}
#[doc = "< Normal cache persistence."]
pub const cudaAccessProperty_cudaAccessPropertyNormal: cudaAccessProperty = 0;
#[doc = "< Streaming access is less likely to persit from cache."]
pub const cudaAccessProperty_cudaAccessPropertyStreaming: cudaAccessProperty = 1;
#[doc = "< Persisting access is more likely to persist in cache."]
pub const cudaAccessProperty_cudaAccessPropertyPersisting: cudaAccessProperty = 2;
#[doc = " Specifies performance hint with ::cudaAccessPolicyWindow for hitProp and missProp members."]
pub type cudaAccessProperty = ::std::os::raw::c_uint;
#[doc = " Specifies an access policy for a window, a contiguous extent of memory\n beginning at base_ptr and ending at base_ptr + num_bytes.\n Partition into many segments and assign segments such that.\n sum of \"hit segments\" / window == approx. ratio.\n sum of \"miss segments\" / window == approx 1-ratio.\n Segments and ratio specifications are fitted to the capabilities of\n the architecture.\n Accesses in a hit segment apply the hitProp access policy.\n Accesses in a miss segment apply the missProp access policy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaAccessPolicyWindow {
    #[doc = "< Starting address of the access policy window. CUDA driver may align it."]
    pub base_ptr: *mut ::std::os::raw::c_void,
    #[doc = "< Size in bytes of the window policy. CUDA driver may restrict the maximum size and alignment."]
    pub num_bytes: usize,
    #[doc = "< hitRatio specifies percentage of lines assigned hitProp, rest are assigned missProp."]
    pub hitRatio: f32,
    #[doc = "< ::CUaccessProperty set for hit."]
    pub hitProp: cudaAccessProperty,
    #[doc = "< ::CUaccessProperty set for miss. Must be either NORMAL or STREAMING."]
    pub missProp: cudaAccessProperty,
}
#[test]
fn bindgen_test_layout_cudaAccessPolicyWindow() {
    const UNINIT: ::std::mem::MaybeUninit<cudaAccessPolicyWindow> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaAccessPolicyWindow>(),
        32usize,
        concat!("Size of: ", stringify!(cudaAccessPolicyWindow))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaAccessPolicyWindow>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaAccessPolicyWindow))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaAccessPolicyWindow),
            "::",
            stringify!(base_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_bytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaAccessPolicyWindow),
            "::",
            stringify!(num_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hitRatio) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaAccessPolicyWindow),
            "::",
            stringify!(hitRatio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hitProp) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaAccessPolicyWindow),
            "::",
            stringify!(hitProp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).missProp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaAccessPolicyWindow),
            "::",
            stringify!(missProp)
        )
    );
}
#[doc = " CUDA host function\n \\param userData Argument value passed to the function"]
pub type cudaHostFn_t =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
#[doc = " CUDA host node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaHostNodeParams {
    #[doc = "< The function to call when the node executes"]
    pub fn_: cudaHostFn_t,
    #[doc = "< Argument to pass to the function"]
    pub userData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaHostNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<cudaHostNodeParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaHostNodeParams>(),
        16usize,
        concat!("Size of: ", stringify!(cudaHostNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaHostNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaHostNodeParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaHostNodeParams),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaHostNodeParams),
            "::",
            stringify!(userData)
        )
    );
}
#[doc = "< Stream is not capturing"]
pub const cudaStreamCaptureStatus_cudaStreamCaptureStatusNone: cudaStreamCaptureStatus = 0;
#[doc = "< Stream is actively capturing"]
pub const cudaStreamCaptureStatus_cudaStreamCaptureStatusActive: cudaStreamCaptureStatus = 1;
#[doc = "< Stream is part of a capture sequence that\nhas been invalidated, but not terminated"]
pub const cudaStreamCaptureStatus_cudaStreamCaptureStatusInvalidated: cudaStreamCaptureStatus = 2;
#[doc = " Possible stream capture statuses returned by ::cudaStreamIsCapturing"]
pub type cudaStreamCaptureStatus = ::std::os::raw::c_uint;
pub const cudaStreamCaptureMode_cudaStreamCaptureModeGlobal: cudaStreamCaptureMode = 0;
pub const cudaStreamCaptureMode_cudaStreamCaptureModeThreadLocal: cudaStreamCaptureMode = 1;
pub const cudaStreamCaptureMode_cudaStreamCaptureModeRelaxed: cudaStreamCaptureMode = 2;
#[doc = " Possible modes for stream capture thread interactions. For more details see\n ::cudaStreamBeginCapture and ::cudaThreadExchangeStreamCaptureMode"]
pub type cudaStreamCaptureMode = ::std::os::raw::c_uint;
pub const cudaSynchronizationPolicy_cudaSyncPolicyAuto: cudaSynchronizationPolicy = 1;
pub const cudaSynchronizationPolicy_cudaSyncPolicySpin: cudaSynchronizationPolicy = 2;
pub const cudaSynchronizationPolicy_cudaSyncPolicyYield: cudaSynchronizationPolicy = 3;
pub const cudaSynchronizationPolicy_cudaSyncPolicyBlockingSync: cudaSynchronizationPolicy = 4;
pub type cudaSynchronizationPolicy = ::std::os::raw::c_uint;
#[doc = "< Identifier for ::cudaStreamAttrValue::accessPolicyWindow."]
pub const cudaStreamAttrID_cudaStreamAttributeAccessPolicyWindow: cudaStreamAttrID = 1;
#[doc = "< ::cudaSynchronizationPolicy for work queued up in this stream"]
pub const cudaStreamAttrID_cudaStreamAttributeSynchronizationPolicy: cudaStreamAttrID = 3;
#[doc = " Stream Attributes"]
pub type cudaStreamAttrID = ::std::os::raw::c_uint;
#[doc = " Stream attributes union used with ::cudaStreamSetAttribute/::cudaStreamGetAttribute"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaStreamAttrValue {
    pub accessPolicyWindow: cudaAccessPolicyWindow,
    pub syncPolicy: cudaSynchronizationPolicy,
}
#[test]
fn bindgen_test_layout_cudaStreamAttrValue() {
    const UNINIT: ::std::mem::MaybeUninit<cudaStreamAttrValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaStreamAttrValue>(),
        32usize,
        concat!("Size of: ", stringify!(cudaStreamAttrValue))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaStreamAttrValue>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaStreamAttrValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessPolicyWindow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaStreamAttrValue),
            "::",
            stringify!(accessPolicyWindow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncPolicy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaStreamAttrValue),
            "::",
            stringify!(syncPolicy)
        )
    );
}
#[doc = "< Add new nodes to the dependency set"]
pub const cudaStreamUpdateCaptureDependenciesFlags_cudaStreamAddCaptureDependencies:
    cudaStreamUpdateCaptureDependenciesFlags = 0;
#[doc = "< Replace the dependency set with the new nodes"]
pub const cudaStreamUpdateCaptureDependenciesFlags_cudaStreamSetCaptureDependencies:
    cudaStreamUpdateCaptureDependenciesFlags = 1;
#[doc = " Flags for ::cudaStreamUpdateCaptureDependencies"]
pub type cudaStreamUpdateCaptureDependenciesFlags = ::std::os::raw::c_uint;
#[doc = "< Indicates the destructor execution is not synchronized by any CUDA handle."]
pub const cudaUserObjectFlags_cudaUserObjectNoDestructorSync: cudaUserObjectFlags = 1;
#[doc = " Flags for user objects for graphs"]
pub type cudaUserObjectFlags = ::std::os::raw::c_uint;
#[doc = "< Transfer references from the caller rather than creating new references."]
pub const cudaUserObjectRetainFlags_cudaGraphUserObjectMove: cudaUserObjectRetainFlags = 1;
#[doc = " Flags for retaining user object references for graphs"]
pub type cudaUserObjectRetainFlags = ::std::os::raw::c_uint;
#[doc = " CUDA graphics interop resource"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaGraphicsResource {
    _unused: [u8; 0],
}
#[doc = "< Default"]
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsNone: cudaGraphicsRegisterFlags = 0;
#[doc = "< CUDA will not write to this resource"]
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsReadOnly: cudaGraphicsRegisterFlags =
    1;
#[doc = "< CUDA will only write to and will not read from this resource"]
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsWriteDiscard:
    cudaGraphicsRegisterFlags = 2;
#[doc = "< CUDA will bind this resource to a surface reference"]
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsSurfaceLoadStore:
    cudaGraphicsRegisterFlags = 4;
#[doc = "< CUDA will perform texture gather operations on this resource"]
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsTextureGather:
    cudaGraphicsRegisterFlags = 8;
#[doc = " CUDA graphics interop register flags"]
pub type cudaGraphicsRegisterFlags = ::std::os::raw::c_uint;
#[doc = "< Default; Assume resource can be read/written"]
pub const cudaGraphicsMapFlags_cudaGraphicsMapFlagsNone: cudaGraphicsMapFlags = 0;
#[doc = "< CUDA will not write to this resource"]
pub const cudaGraphicsMapFlags_cudaGraphicsMapFlagsReadOnly: cudaGraphicsMapFlags = 1;
#[doc = "< CUDA will only write to and will not read from this resource"]
pub const cudaGraphicsMapFlags_cudaGraphicsMapFlagsWriteDiscard: cudaGraphicsMapFlags = 2;
#[doc = " CUDA graphics interop map flags"]
pub type cudaGraphicsMapFlags = ::std::os::raw::c_uint;
#[doc = "< Positive X face of cubemap"]
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFacePositiveX: cudaGraphicsCubeFace = 0;
#[doc = "< Negative X face of cubemap"]
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFaceNegativeX: cudaGraphicsCubeFace = 1;
#[doc = "< Positive Y face of cubemap"]
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFacePositiveY: cudaGraphicsCubeFace = 2;
#[doc = "< Negative Y face of cubemap"]
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFaceNegativeY: cudaGraphicsCubeFace = 3;
#[doc = "< Positive Z face of cubemap"]
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFacePositiveZ: cudaGraphicsCubeFace = 4;
#[doc = "< Negative Z face of cubemap"]
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFaceNegativeZ: cudaGraphicsCubeFace = 5;
#[doc = " CUDA graphics interop array indices for cube maps"]
pub type cudaGraphicsCubeFace = ::std::os::raw::c_uint;
#[doc = "< Identifier for ::cudaKernelNodeAttrValue::accessPolicyWindow."]
pub const cudaKernelNodeAttrID_cudaKernelNodeAttributeAccessPolicyWindow: cudaKernelNodeAttrID = 1;
#[doc = "< Allows a kernel node to be cooperative (see ::cudaLaunchCooperativeKernel)."]
pub const cudaKernelNodeAttrID_cudaKernelNodeAttributeCooperative: cudaKernelNodeAttrID = 2;
#[doc = " Graph kernel node Attributes"]
pub type cudaKernelNodeAttrID = ::std::os::raw::c_uint;
#[doc = " Graph kernel node attributes union, used with ::cudaGraphKernelNodeSetAttribute/::cudaGraphKernelNodeGetAttribute"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaKernelNodeAttrValue {
    #[doc = "< Attribute ::CUaccessPolicyWindow."]
    pub accessPolicyWindow: cudaAccessPolicyWindow,
    pub cooperative: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cudaKernelNodeAttrValue() {
    const UNINIT: ::std::mem::MaybeUninit<cudaKernelNodeAttrValue> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaKernelNodeAttrValue>(),
        32usize,
        concat!("Size of: ", stringify!(cudaKernelNodeAttrValue))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaKernelNodeAttrValue>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaKernelNodeAttrValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessPolicyWindow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeAttrValue),
            "::",
            stringify!(accessPolicyWindow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cooperative) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeAttrValue),
            "::",
            stringify!(cooperative)
        )
    );
}
#[doc = "< Array resource"]
pub const cudaResourceType_cudaResourceTypeArray: cudaResourceType = 0;
#[doc = "< Mipmapped array resource"]
pub const cudaResourceType_cudaResourceTypeMipmappedArray: cudaResourceType = 1;
#[doc = "< Linear resource"]
pub const cudaResourceType_cudaResourceTypeLinear: cudaResourceType = 2;
#[doc = "< Pitch 2D resource"]
pub const cudaResourceType_cudaResourceTypePitch2D: cudaResourceType = 3;
#[doc = " CUDA resource types"]
pub type cudaResourceType = ::std::os::raw::c_uint;
#[doc = "< No resource view format (use underlying resource format)"]
pub const cudaResourceViewFormat_cudaResViewFormatNone: cudaResourceViewFormat = 0;
#[doc = "< 1 channel unsigned 8-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedChar1: cudaResourceViewFormat = 1;
#[doc = "< 2 channel unsigned 8-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedChar2: cudaResourceViewFormat = 2;
#[doc = "< 4 channel unsigned 8-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedChar4: cudaResourceViewFormat = 3;
#[doc = "< 1 channel signed 8-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedChar1: cudaResourceViewFormat = 4;
#[doc = "< 2 channel signed 8-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedChar2: cudaResourceViewFormat = 5;
#[doc = "< 4 channel signed 8-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedChar4: cudaResourceViewFormat = 6;
#[doc = "< 1 channel unsigned 16-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedShort1: cudaResourceViewFormat = 7;
#[doc = "< 2 channel unsigned 16-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedShort2: cudaResourceViewFormat = 8;
#[doc = "< 4 channel unsigned 16-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedShort4: cudaResourceViewFormat = 9;
#[doc = "< 1 channel signed 16-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedShort1: cudaResourceViewFormat = 10;
#[doc = "< 2 channel signed 16-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedShort2: cudaResourceViewFormat = 11;
#[doc = "< 4 channel signed 16-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedShort4: cudaResourceViewFormat = 12;
#[doc = "< 1 channel unsigned 32-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedInt1: cudaResourceViewFormat = 13;
#[doc = "< 2 channel unsigned 32-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedInt2: cudaResourceViewFormat = 14;
#[doc = "< 4 channel unsigned 32-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedInt4: cudaResourceViewFormat = 15;
#[doc = "< 1 channel signed 32-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedInt1: cudaResourceViewFormat = 16;
#[doc = "< 2 channel signed 32-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedInt2: cudaResourceViewFormat = 17;
#[doc = "< 4 channel signed 32-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedInt4: cudaResourceViewFormat = 18;
#[doc = "< 1 channel 16-bit floating point"]
pub const cudaResourceViewFormat_cudaResViewFormatHalf1: cudaResourceViewFormat = 19;
#[doc = "< 2 channel 16-bit floating point"]
pub const cudaResourceViewFormat_cudaResViewFormatHalf2: cudaResourceViewFormat = 20;
#[doc = "< 4 channel 16-bit floating point"]
pub const cudaResourceViewFormat_cudaResViewFormatHalf4: cudaResourceViewFormat = 21;
#[doc = "< 1 channel 32-bit floating point"]
pub const cudaResourceViewFormat_cudaResViewFormatFloat1: cudaResourceViewFormat = 22;
#[doc = "< 2 channel 32-bit floating point"]
pub const cudaResourceViewFormat_cudaResViewFormatFloat2: cudaResourceViewFormat = 23;
#[doc = "< 4 channel 32-bit floating point"]
pub const cudaResourceViewFormat_cudaResViewFormatFloat4: cudaResourceViewFormat = 24;
#[doc = "< Block compressed 1"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed1: cudaResourceViewFormat =
    25;
#[doc = "< Block compressed 2"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed2: cudaResourceViewFormat =
    26;
#[doc = "< Block compressed 3"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed3: cudaResourceViewFormat =
    27;
#[doc = "< Block compressed 4 unsigned"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed4: cudaResourceViewFormat =
    28;
#[doc = "< Block compressed 4 signed"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedBlockCompressed4: cudaResourceViewFormat =
    29;
#[doc = "< Block compressed 5 unsigned"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed5: cudaResourceViewFormat =
    30;
#[doc = "< Block compressed 5 signed"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedBlockCompressed5: cudaResourceViewFormat =
    31;
#[doc = "< Block compressed 6 unsigned half-float"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed6H:
    cudaResourceViewFormat = 32;
#[doc = "< Block compressed 6 signed half-float"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedBlockCompressed6H: cudaResourceViewFormat =
    33;
#[doc = "< Block compressed 7"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed7: cudaResourceViewFormat =
    34;
#[doc = " CUDA texture resource view formats"]
pub type cudaResourceViewFormat = ::std::os::raw::c_uint;
#[doc = " CUDA resource descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaResourceDesc {
    #[doc = "< Resource type"]
    pub resType: cudaResourceType,
    pub res: cudaResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaResourceDesc__bindgen_ty_1 {
    pub array: cudaResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: cudaResourceDesc__bindgen_ty_1__bindgen_ty_2,
    pub linear: cudaResourceDesc__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: cudaResourceDesc__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< CUDA array"]
    pub array: cudaArray_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< CUDA mipmapped array"]
    pub mipmap: cudaMipmappedArray_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mipmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer"]
    pub devPtr: *mut ::std::os::raw::c_void,
    #[doc = "< Channel descriptor"]
    pub desc: cudaChannelFormatDesc,
    #[doc = "< Size in bytes"]
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeInBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer"]
    pub devPtr: *mut ::std::os::raw::c_void,
    #[doc = "< Channel descriptor"]
    pub desc: cudaChannelFormatDesc,
    #[doc = "< Width of the array in elements"]
    pub width: usize,
    #[doc = "< Height of the array in elements"]
    pub height: usize,
    #[doc = "< Pitch between two rows in bytes"]
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitchInBytes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<cudaResourceDesc__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(cudaResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch2D) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaResourceDesc() {
    const UNINIT: ::std::mem::MaybeUninit<cudaResourceDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc>(),
        64usize,
        concat!("Size of: ", stringify!(cudaResourceDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc),
            "::",
            stringify!(res)
        )
    );
}
#[doc = " CUDA resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceViewDesc {
    #[doc = "< Resource view format"]
    pub format: cudaResourceViewFormat,
    #[doc = "< Width of the resource view"]
    pub width: usize,
    #[doc = "< Height of the resource view"]
    pub height: usize,
    #[doc = "< Depth of the resource view"]
    pub depth: usize,
    #[doc = "< First defined mipmap level"]
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< Last defined mipmap level"]
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< First layer index"]
    pub firstLayer: ::std::os::raw::c_uint,
    #[doc = "< Last layer index"]
    pub lastLayer: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaResourceViewDesc() {
    const UNINIT: ::std::mem::MaybeUninit<cudaResourceViewDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaResourceViewDesc>(),
        48usize,
        concat!("Size of: ", stringify!(cudaResourceViewDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceViewDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceViewDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firstMipmapLevel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastMipmapLevel) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firstLayer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastLayer) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(lastLayer)
        )
    );
}
#[doc = " CUDA pointer attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPointerAttributes {
    #[doc = " The type of memory - ::cudaMemoryTypeUnregistered, ::cudaMemoryTypeHost,\n ::cudaMemoryTypeDevice or ::cudaMemoryTypeManaged."]
    pub type_: cudaMemoryType,
    #[doc = " The device against which the memory was allocated or registered.\n If the memory type is ::cudaMemoryTypeDevice then this identifies\n the device on which the memory referred physically resides.  If\n the memory type is ::cudaMemoryTypeHost or::cudaMemoryTypeManaged then\n this identifies the device which was current when the memory was allocated\n or registered (and if that device is deinitialized then this allocation\n will vanish with that device's state)."]
    pub device: ::std::os::raw::c_int,
    #[doc = " The address which may be dereferenced on the current device to access\n the memory or NULL if no such address exists."]
    pub devicePointer: *mut ::std::os::raw::c_void,
    #[doc = " The address which may be dereferenced on the host to access the\n memory or NULL if no such address exists.\n\n \\note CUDA doesn't check if unregistered memory is allocated so this field\n may contain invalid pointer if an invalid pointer has been passed to CUDA."]
    pub hostPointer: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaPointerAttributes() {
    const UNINIT: ::std::mem::MaybeUninit<cudaPointerAttributes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaPointerAttributes>(),
        24usize,
        concat!("Size of: ", stringify!(cudaPointerAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPointerAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPointerAttributes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devicePointer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(devicePointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostPointer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(hostPointer)
        )
    );
}
#[doc = " CUDA function attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaFuncAttributes {
    #[doc = " The size in bytes of statically-allocated shared memory per block\n required by this function. This does not include dynamically-allocated\n shared memory requested by the user at runtime."]
    pub sharedSizeBytes: usize,
    #[doc = " The size in bytes of user-allocated constant memory required by this\n function."]
    pub constSizeBytes: usize,
    #[doc = " The size in bytes of local memory used by each thread of this function."]
    pub localSizeBytes: usize,
    #[doc = " The maximum number of threads per block, beyond which a launch of the\n function would fail. This number depends on both the function and the\n device on which the function is currently loaded."]
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    #[doc = " The number of registers used by each thread of this function."]
    pub numRegs: ::std::os::raw::c_int,
    #[doc = " The PTX virtual architecture version for which the function was\n compiled. This value is the major PTX version * 10 + the minor PTX\n version, so a PTX version 1.3 function would return the value 13."]
    pub ptxVersion: ::std::os::raw::c_int,
    #[doc = " The binary architecture version for which the function was compiled.\n This value is the major binary version * 10 + the minor binary version,\n so a binary version 1.3 function would return the value 13."]
    pub binaryVersion: ::std::os::raw::c_int,
    #[doc = " The attribute to indicate whether the function has been compiled with\n user specified option \"-Xptxas --dlcm=ca\" set."]
    pub cacheModeCA: ::std::os::raw::c_int,
    #[doc = " The maximum size in bytes of dynamic shared memory per block for\n this function. Any launch must have a dynamic shared memory size\n smaller than this value."]
    pub maxDynamicSharedSizeBytes: ::std::os::raw::c_int,
    #[doc = " On devices where the L1 cache and shared memory use the same hardware resources,\n this sets the shared memory carveout preference, in percent of the maximum shared memory.\n Refer to ::cudaDevAttrMaxSharedMemoryPerMultiprocessor.\n This is only a hint, and the driver can choose a different ratio if required to execute the function.\n See ::cudaFuncSetAttribute"]
    pub preferredShmemCarveout: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cudaFuncAttributes() {
    const UNINIT: ::std::mem::MaybeUninit<cudaFuncAttributes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaFuncAttributes>(),
        56usize,
        concat!("Size of: ", stringify!(cudaFuncAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaFuncAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaFuncAttributes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedSizeBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(sharedSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constSizeBytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(constSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localSizeBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(localSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxThreadsPerBlock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numRegs) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(numRegs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptxVersion) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(ptxVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binaryVersion) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(binaryVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cacheModeCA) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(cacheModeCA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxDynamicSharedSizeBytes) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(maxDynamicSharedSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preferredShmemCarveout) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(preferredShmemCarveout)
        )
    );
}
#[doc = "< Maximum dynamic shared memory size"]
pub const cudaFuncAttribute_cudaFuncAttributeMaxDynamicSharedMemorySize: cudaFuncAttribute = 8;
#[doc = "< Preferred shared memory-L1 cache split"]
pub const cudaFuncAttribute_cudaFuncAttributePreferredSharedMemoryCarveout: cudaFuncAttribute = 9;
pub const cudaFuncAttribute_cudaFuncAttributeMax: cudaFuncAttribute = 10;
#[doc = " CUDA function attributes that can be set using ::cudaFuncSetAttribute"]
pub type cudaFuncAttribute = ::std::os::raw::c_uint;
#[doc = "< Default function cache configuration, no preference"]
pub const cudaFuncCache_cudaFuncCachePreferNone: cudaFuncCache = 0;
#[doc = "< Prefer larger shared memory and smaller L1 cache"]
pub const cudaFuncCache_cudaFuncCachePreferShared: cudaFuncCache = 1;
#[doc = "< Prefer larger L1 cache and smaller shared memory"]
pub const cudaFuncCache_cudaFuncCachePreferL1: cudaFuncCache = 2;
#[doc = "< Prefer equal size L1 cache and shared memory"]
pub const cudaFuncCache_cudaFuncCachePreferEqual: cudaFuncCache = 3;
#[doc = " CUDA function cache configurations"]
pub type cudaFuncCache = ::std::os::raw::c_uint;
pub const cudaSharedMemConfig_cudaSharedMemBankSizeDefault: cudaSharedMemConfig = 0;
pub const cudaSharedMemConfig_cudaSharedMemBankSizeFourByte: cudaSharedMemConfig = 1;
pub const cudaSharedMemConfig_cudaSharedMemBankSizeEightByte: cudaSharedMemConfig = 2;
#[doc = " CUDA shared memory configuration"]
pub type cudaSharedMemConfig = ::std::os::raw::c_uint;
#[doc = "< No preference for shared memory or L1 (default)"]
pub const cudaSharedCarveout_cudaSharedmemCarveoutDefault: cudaSharedCarveout = -1;
#[doc = "< Prefer maximum available shared memory, minimum L1 cache"]
pub const cudaSharedCarveout_cudaSharedmemCarveoutMaxShared: cudaSharedCarveout = 100;
#[doc = "< Prefer maximum available L1 cache, minimum shared memory"]
pub const cudaSharedCarveout_cudaSharedmemCarveoutMaxL1: cudaSharedCarveout = 0;
#[doc = " Shared memory carveout configurations. These may be passed to cudaFuncSetAttribute"]
pub type cudaSharedCarveout = ::std::os::raw::c_int;
#[doc = "< Default compute mode (Multiple threads can use ::cudaSetDevice() with this device)"]
pub const cudaComputeMode_cudaComputeModeDefault: cudaComputeMode = 0;
#[doc = "< Compute-exclusive-thread mode (Only one thread in one process will be able to use ::cudaSetDevice() with this device)"]
pub const cudaComputeMode_cudaComputeModeExclusive: cudaComputeMode = 1;
#[doc = "< Compute-prohibited mode (No threads can use ::cudaSetDevice() with this device)"]
pub const cudaComputeMode_cudaComputeModeProhibited: cudaComputeMode = 2;
#[doc = "< Compute-exclusive-process mode (Many threads in one process will be able to use ::cudaSetDevice() with this device)"]
pub const cudaComputeMode_cudaComputeModeExclusiveProcess: cudaComputeMode = 3;
#[doc = " CUDA device compute modes"]
pub type cudaComputeMode = ::std::os::raw::c_uint;
#[doc = "< GPU thread stack size"]
pub const cudaLimit_cudaLimitStackSize: cudaLimit = 0;
#[doc = "< GPU printf FIFO size"]
pub const cudaLimit_cudaLimitPrintfFifoSize: cudaLimit = 1;
#[doc = "< GPU malloc heap size"]
pub const cudaLimit_cudaLimitMallocHeapSize: cudaLimit = 2;
#[doc = "< GPU device runtime synchronize depth"]
pub const cudaLimit_cudaLimitDevRuntimeSyncDepth: cudaLimit = 3;
#[doc = "< GPU device runtime pending launch count"]
pub const cudaLimit_cudaLimitDevRuntimePendingLaunchCount: cudaLimit = 4;
#[doc = "< A value between 0 and 128 that indicates the maximum fetch granularity of L2 (in Bytes). This is a hint"]
pub const cudaLimit_cudaLimitMaxL2FetchGranularity: cudaLimit = 5;
#[doc = "< A size in bytes for L2 persisting lines cache size"]
pub const cudaLimit_cudaLimitPersistingL2CacheSize: cudaLimit = 6;
#[doc = " CUDA Limits"]
pub type cudaLimit = ::std::os::raw::c_uint;
#[doc = "< Data will mostly be read and only occassionally be written to"]
pub const cudaMemoryAdvise_cudaMemAdviseSetReadMostly: cudaMemoryAdvise = 1;
#[doc = "< Undo the effect of ::cudaMemAdviseSetReadMostly"]
pub const cudaMemoryAdvise_cudaMemAdviseUnsetReadMostly: cudaMemoryAdvise = 2;
#[doc = "< Set the preferred location for the data as the specified device"]
pub const cudaMemoryAdvise_cudaMemAdviseSetPreferredLocation: cudaMemoryAdvise = 3;
#[doc = "< Clear the preferred location for the data"]
pub const cudaMemoryAdvise_cudaMemAdviseUnsetPreferredLocation: cudaMemoryAdvise = 4;
#[doc = "< Data will be accessed by the specified device, so prevent page faults as much as possible"]
pub const cudaMemoryAdvise_cudaMemAdviseSetAccessedBy: cudaMemoryAdvise = 5;
#[doc = "< Let the Unified Memory subsystem decide on the page faulting policy for the specified device"]
pub const cudaMemoryAdvise_cudaMemAdviseUnsetAccessedBy: cudaMemoryAdvise = 6;
#[doc = " CUDA Memory Advise values"]
pub type cudaMemoryAdvise = ::std::os::raw::c_uint;
#[doc = "< Whether the range will mostly be read and only occassionally be written to"]
pub const cudaMemRangeAttribute_cudaMemRangeAttributeReadMostly: cudaMemRangeAttribute = 1;
#[doc = "< The preferred location of the range"]
pub const cudaMemRangeAttribute_cudaMemRangeAttributePreferredLocation: cudaMemRangeAttribute = 2;
#[doc = "< Memory range has ::cudaMemAdviseSetAccessedBy set for specified device"]
pub const cudaMemRangeAttribute_cudaMemRangeAttributeAccessedBy: cudaMemRangeAttribute = 3;
#[doc = "< The last location to which the range was prefetched"]
pub const cudaMemRangeAttribute_cudaMemRangeAttributeLastPrefetchLocation: cudaMemRangeAttribute =
    4;
#[doc = " CUDA range attributes"]
pub type cudaMemRangeAttribute = ::std::os::raw::c_uint;
#[doc = "< Output mode Key-Value pair format."]
pub const cudaOutputMode_cudaKeyValuePair: cudaOutputMode = 0;
#[doc = "< Output mode Comma separated values format."]
pub const cudaOutputMode_cudaCSV: cudaOutputMode = 1;
#[doc = " CUDA Profiler Output modes"]
pub type cudaOutputMode = ::std::os::raw::c_uint;
#[doc = "< ::cudaDeviceFlushGPUDirectRDMAWrites() and its CUDA Driver API counterpart are supported on the device."]
pub const cudaFlushGPUDirectRDMAWritesOptions_cudaFlushGPUDirectRDMAWritesOptionHost:
    cudaFlushGPUDirectRDMAWritesOptions = 1;
#[doc = "< The ::CU_STREAM_WAIT_VALUE_FLUSH flag and the ::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES MemOp are supported on the CUDA device."]
pub const cudaFlushGPUDirectRDMAWritesOptions_cudaFlushGPUDirectRDMAWritesOptionMemOps:
    cudaFlushGPUDirectRDMAWritesOptions = 2;
#[doc = " CUDA GPUDirect RDMA flush writes APIs supported on the device"]
pub type cudaFlushGPUDirectRDMAWritesOptions = ::std::os::raw::c_uint;
#[doc = "< The device does not natively support ordering of GPUDirect RDMA writes. ::cudaFlushGPUDirectRDMAWrites() can be leveraged if supported."]
pub const cudaGPUDirectRDMAWritesOrdering_cudaGPUDirectRDMAWritesOrderingNone:
    cudaGPUDirectRDMAWritesOrdering = 0;
#[doc = "< Natively, the device can consistently consume GPUDirect RDMA writes, although other CUDA devices may not."]
pub const cudaGPUDirectRDMAWritesOrdering_cudaGPUDirectRDMAWritesOrderingOwner:
    cudaGPUDirectRDMAWritesOrdering = 100;
#[doc = "< Any CUDA device in the system can consistently consume GPUDirect RDMA writes to this device."]
pub const cudaGPUDirectRDMAWritesOrdering_cudaGPUDirectRDMAWritesOrderingAllDevices:
    cudaGPUDirectRDMAWritesOrdering = 200;
#[doc = " CUDA GPUDirect RDMA flush writes ordering features of the device"]
pub type cudaGPUDirectRDMAWritesOrdering = ::std::os::raw::c_uint;
#[doc = "< Blocks until remote writes are visible to the CUDA device context owning the data."]
pub const cudaFlushGPUDirectRDMAWritesScope_cudaFlushGPUDirectRDMAWritesToOwner:
    cudaFlushGPUDirectRDMAWritesScope = 100;
#[doc = "< Blocks until remote writes are visible to all CUDA device contexts."]
pub const cudaFlushGPUDirectRDMAWritesScope_cudaFlushGPUDirectRDMAWritesToAllDevices:
    cudaFlushGPUDirectRDMAWritesScope = 200;
#[doc = " CUDA GPUDirect RDMA flush writes scopes"]
pub type cudaFlushGPUDirectRDMAWritesScope = ::std::os::raw::c_uint;
#[doc = "< Sets the target for ::cudaDeviceFlushGPUDirectRDMAWrites() to the currently active CUDA device context."]
pub const cudaFlushGPUDirectRDMAWritesTarget_cudaFlushGPUDirectRDMAWritesTargetCurrentDevice:
    cudaFlushGPUDirectRDMAWritesTarget = 0;
#[doc = " CUDA GPUDirect RDMA flush writes targets"]
pub type cudaFlushGPUDirectRDMAWritesTarget = ::std::os::raw::c_uint;
#[doc = "< Maximum number of threads per block"]
pub const cudaDeviceAttr_cudaDevAttrMaxThreadsPerBlock: cudaDeviceAttr = 1;
#[doc = "< Maximum block dimension X"]
pub const cudaDeviceAttr_cudaDevAttrMaxBlockDimX: cudaDeviceAttr = 2;
#[doc = "< Maximum block dimension Y"]
pub const cudaDeviceAttr_cudaDevAttrMaxBlockDimY: cudaDeviceAttr = 3;
#[doc = "< Maximum block dimension Z"]
pub const cudaDeviceAttr_cudaDevAttrMaxBlockDimZ: cudaDeviceAttr = 4;
#[doc = "< Maximum grid dimension X"]
pub const cudaDeviceAttr_cudaDevAttrMaxGridDimX: cudaDeviceAttr = 5;
#[doc = "< Maximum grid dimension Y"]
pub const cudaDeviceAttr_cudaDevAttrMaxGridDimY: cudaDeviceAttr = 6;
#[doc = "< Maximum grid dimension Z"]
pub const cudaDeviceAttr_cudaDevAttrMaxGridDimZ: cudaDeviceAttr = 7;
#[doc = "< Maximum shared memory available per block in bytes"]
pub const cudaDeviceAttr_cudaDevAttrMaxSharedMemoryPerBlock: cudaDeviceAttr = 8;
#[doc = "< Memory available on device for __constant__ variables in a CUDA C kernel in bytes"]
pub const cudaDeviceAttr_cudaDevAttrTotalConstantMemory: cudaDeviceAttr = 9;
#[doc = "< Warp size in threads"]
pub const cudaDeviceAttr_cudaDevAttrWarpSize: cudaDeviceAttr = 10;
#[doc = "< Maximum pitch in bytes allowed by memory copies"]
pub const cudaDeviceAttr_cudaDevAttrMaxPitch: cudaDeviceAttr = 11;
#[doc = "< Maximum number of 32-bit registers available per block"]
pub const cudaDeviceAttr_cudaDevAttrMaxRegistersPerBlock: cudaDeviceAttr = 12;
#[doc = "< Peak clock frequency in kilohertz"]
pub const cudaDeviceAttr_cudaDevAttrClockRate: cudaDeviceAttr = 13;
#[doc = "< Alignment requirement for textures"]
pub const cudaDeviceAttr_cudaDevAttrTextureAlignment: cudaDeviceAttr = 14;
#[doc = "< Device can possibly copy memory and execute a kernel concurrently"]
pub const cudaDeviceAttr_cudaDevAttrGpuOverlap: cudaDeviceAttr = 15;
#[doc = "< Number of multiprocessors on device"]
pub const cudaDeviceAttr_cudaDevAttrMultiProcessorCount: cudaDeviceAttr = 16;
#[doc = "< Specifies whether there is a run time limit on kernels"]
pub const cudaDeviceAttr_cudaDevAttrKernelExecTimeout: cudaDeviceAttr = 17;
#[doc = "< Device is integrated with host memory"]
pub const cudaDeviceAttr_cudaDevAttrIntegrated: cudaDeviceAttr = 18;
#[doc = "< Device can map host memory into CUDA address space"]
pub const cudaDeviceAttr_cudaDevAttrCanMapHostMemory: cudaDeviceAttr = 19;
#[doc = "< Compute mode (See ::cudaComputeMode for details)"]
pub const cudaDeviceAttr_cudaDevAttrComputeMode: cudaDeviceAttr = 20;
#[doc = "< Maximum 1D texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DWidth: cudaDeviceAttr = 21;
#[doc = "< Maximum 2D texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DWidth: cudaDeviceAttr = 22;
#[doc = "< Maximum 2D texture height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DHeight: cudaDeviceAttr = 23;
#[doc = "< Maximum 3D texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DWidth: cudaDeviceAttr = 24;
#[doc = "< Maximum 3D texture height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DHeight: cudaDeviceAttr = 25;
#[doc = "< Maximum 3D texture depth"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DDepth: cudaDeviceAttr = 26;
#[doc = "< Maximum 2D layered texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLayeredWidth: cudaDeviceAttr = 27;
#[doc = "< Maximum 2D layered texture height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLayeredHeight: cudaDeviceAttr = 28;
#[doc = "< Maximum layers in a 2D layered texture"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLayeredLayers: cudaDeviceAttr = 29;
#[doc = "< Alignment requirement for surfaces"]
pub const cudaDeviceAttr_cudaDevAttrSurfaceAlignment: cudaDeviceAttr = 30;
#[doc = "< Device can possibly execute multiple kernels concurrently"]
pub const cudaDeviceAttr_cudaDevAttrConcurrentKernels: cudaDeviceAttr = 31;
#[doc = "< Device has ECC support enabled"]
pub const cudaDeviceAttr_cudaDevAttrEccEnabled: cudaDeviceAttr = 32;
#[doc = "< PCI bus ID of the device"]
pub const cudaDeviceAttr_cudaDevAttrPciBusId: cudaDeviceAttr = 33;
#[doc = "< PCI device ID of the device"]
pub const cudaDeviceAttr_cudaDevAttrPciDeviceId: cudaDeviceAttr = 34;
#[doc = "< Device is using TCC driver model"]
pub const cudaDeviceAttr_cudaDevAttrTccDriver: cudaDeviceAttr = 35;
#[doc = "< Peak memory clock frequency in kilohertz"]
pub const cudaDeviceAttr_cudaDevAttrMemoryClockRate: cudaDeviceAttr = 36;
#[doc = "< Global memory bus width in bits"]
pub const cudaDeviceAttr_cudaDevAttrGlobalMemoryBusWidth: cudaDeviceAttr = 37;
#[doc = "< Size of L2 cache in bytes"]
pub const cudaDeviceAttr_cudaDevAttrL2CacheSize: cudaDeviceAttr = 38;
#[doc = "< Maximum resident threads per multiprocessor"]
pub const cudaDeviceAttr_cudaDevAttrMaxThreadsPerMultiProcessor: cudaDeviceAttr = 39;
#[doc = "< Number of asynchronous engines"]
pub const cudaDeviceAttr_cudaDevAttrAsyncEngineCount: cudaDeviceAttr = 40;
#[doc = "< Device shares a unified address space with the host"]
pub const cudaDeviceAttr_cudaDevAttrUnifiedAddressing: cudaDeviceAttr = 41;
#[doc = "< Maximum 1D layered texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DLayeredWidth: cudaDeviceAttr = 42;
#[doc = "< Maximum layers in a 1D layered texture"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DLayeredLayers: cudaDeviceAttr = 43;
#[doc = "< Maximum 2D texture width if cudaArrayTextureGather is set"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DGatherWidth: cudaDeviceAttr = 45;
#[doc = "< Maximum 2D texture height if cudaArrayTextureGather is set"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DGatherHeight: cudaDeviceAttr = 46;
#[doc = "< Alternate maximum 3D texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DWidthAlt: cudaDeviceAttr = 47;
#[doc = "< Alternate maximum 3D texture height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DHeightAlt: cudaDeviceAttr = 48;
#[doc = "< Alternate maximum 3D texture depth"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DDepthAlt: cudaDeviceAttr = 49;
#[doc = "< PCI domain ID of the device"]
pub const cudaDeviceAttr_cudaDevAttrPciDomainId: cudaDeviceAttr = 50;
#[doc = "< Pitch alignment requirement for textures"]
pub const cudaDeviceAttr_cudaDevAttrTexturePitchAlignment: cudaDeviceAttr = 51;
#[doc = "< Maximum cubemap texture width/height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTextureCubemapWidth: cudaDeviceAttr = 52;
#[doc = "< Maximum cubemap layered texture width/height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTextureCubemapLayeredWidth: cudaDeviceAttr = 53;
#[doc = "< Maximum layers in a cubemap layered texture"]
pub const cudaDeviceAttr_cudaDevAttrMaxTextureCubemapLayeredLayers: cudaDeviceAttr = 54;
#[doc = "< Maximum 1D surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface1DWidth: cudaDeviceAttr = 55;
#[doc = "< Maximum 2D surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DWidth: cudaDeviceAttr = 56;
#[doc = "< Maximum 2D surface height"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DHeight: cudaDeviceAttr = 57;
#[doc = "< Maximum 3D surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface3DWidth: cudaDeviceAttr = 58;
#[doc = "< Maximum 3D surface height"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface3DHeight: cudaDeviceAttr = 59;
#[doc = "< Maximum 3D surface depth"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface3DDepth: cudaDeviceAttr = 60;
#[doc = "< Maximum 1D layered surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface1DLayeredWidth: cudaDeviceAttr = 61;
#[doc = "< Maximum layers in a 1D layered surface"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface1DLayeredLayers: cudaDeviceAttr = 62;
#[doc = "< Maximum 2D layered surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DLayeredWidth: cudaDeviceAttr = 63;
#[doc = "< Maximum 2D layered surface height"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DLayeredHeight: cudaDeviceAttr = 64;
#[doc = "< Maximum layers in a 2D layered surface"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DLayeredLayers: cudaDeviceAttr = 65;
#[doc = "< Maximum cubemap surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurfaceCubemapWidth: cudaDeviceAttr = 66;
#[doc = "< Maximum cubemap layered surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurfaceCubemapLayeredWidth: cudaDeviceAttr = 67;
#[doc = "< Maximum layers in a cubemap layered surface"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurfaceCubemapLayeredLayers: cudaDeviceAttr = 68;
#[doc = "< Maximum 1D linear texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DLinearWidth: cudaDeviceAttr = 69;
#[doc = "< Maximum 2D linear texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLinearWidth: cudaDeviceAttr = 70;
#[doc = "< Maximum 2D linear texture height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLinearHeight: cudaDeviceAttr = 71;
#[doc = "< Maximum 2D linear texture pitch in bytes"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLinearPitch: cudaDeviceAttr = 72;
#[doc = "< Maximum mipmapped 2D texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DMipmappedWidth: cudaDeviceAttr = 73;
#[doc = "< Maximum mipmapped 2D texture height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DMipmappedHeight: cudaDeviceAttr = 74;
#[doc = "< Major compute capability version number"]
pub const cudaDeviceAttr_cudaDevAttrComputeCapabilityMajor: cudaDeviceAttr = 75;
#[doc = "< Minor compute capability version number"]
pub const cudaDeviceAttr_cudaDevAttrComputeCapabilityMinor: cudaDeviceAttr = 76;
#[doc = "< Maximum mipmapped 1D texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DMipmappedWidth: cudaDeviceAttr = 77;
#[doc = "< Device supports stream priorities"]
pub const cudaDeviceAttr_cudaDevAttrStreamPrioritiesSupported: cudaDeviceAttr = 78;
#[doc = "< Device supports caching globals in L1"]
pub const cudaDeviceAttr_cudaDevAttrGlobalL1CacheSupported: cudaDeviceAttr = 79;
#[doc = "< Device supports caching locals in L1"]
pub const cudaDeviceAttr_cudaDevAttrLocalL1CacheSupported: cudaDeviceAttr = 80;
#[doc = "< Maximum shared memory available per multiprocessor in bytes"]
pub const cudaDeviceAttr_cudaDevAttrMaxSharedMemoryPerMultiprocessor: cudaDeviceAttr = 81;
#[doc = "< Maximum number of 32-bit registers available per multiprocessor"]
pub const cudaDeviceAttr_cudaDevAttrMaxRegistersPerMultiprocessor: cudaDeviceAttr = 82;
#[doc = "< Device can allocate managed memory on this system"]
pub const cudaDeviceAttr_cudaDevAttrManagedMemory: cudaDeviceAttr = 83;
#[doc = "< Device is on a multi-GPU board"]
pub const cudaDeviceAttr_cudaDevAttrIsMultiGpuBoard: cudaDeviceAttr = 84;
#[doc = "< Unique identifier for a group of devices on the same multi-GPU board"]
pub const cudaDeviceAttr_cudaDevAttrMultiGpuBoardGroupID: cudaDeviceAttr = 85;
#[doc = "< Link between the device and the host supports native atomic operations"]
pub const cudaDeviceAttr_cudaDevAttrHostNativeAtomicSupported: cudaDeviceAttr = 86;
#[doc = "< Ratio of single precision performance (in floating-point operations per second) to double precision performance"]
pub const cudaDeviceAttr_cudaDevAttrSingleToDoublePrecisionPerfRatio: cudaDeviceAttr = 87;
#[doc = "< Device supports coherently accessing pageable memory without calling cudaHostRegister on it"]
pub const cudaDeviceAttr_cudaDevAttrPageableMemoryAccess: cudaDeviceAttr = 88;
#[doc = "< Device can coherently access managed memory concurrently with the CPU"]
pub const cudaDeviceAttr_cudaDevAttrConcurrentManagedAccess: cudaDeviceAttr = 89;
#[doc = "< Device supports Compute Preemption"]
pub const cudaDeviceAttr_cudaDevAttrComputePreemptionSupported: cudaDeviceAttr = 90;
#[doc = "< Device can access host registered memory at the same virtual address as the CPU"]
pub const cudaDeviceAttr_cudaDevAttrCanUseHostPointerForRegisteredMem: cudaDeviceAttr = 91;
pub const cudaDeviceAttr_cudaDevAttrReserved92: cudaDeviceAttr = 92;
pub const cudaDeviceAttr_cudaDevAttrReserved93: cudaDeviceAttr = 93;
pub const cudaDeviceAttr_cudaDevAttrReserved94: cudaDeviceAttr = 94;
#[doc = "< Device supports launching cooperative kernels via ::cudaLaunchCooperativeKernel"]
pub const cudaDeviceAttr_cudaDevAttrCooperativeLaunch: cudaDeviceAttr = 95;
#[doc = "< Deprecated, cudaLaunchCooperativeKernelMultiDevice is deprecated."]
pub const cudaDeviceAttr_cudaDevAttrCooperativeMultiDeviceLaunch: cudaDeviceAttr = 96;
#[doc = "< The maximum optin shared memory per block. This value may vary by chip. See ::cudaFuncSetAttribute"]
pub const cudaDeviceAttr_cudaDevAttrMaxSharedMemoryPerBlockOptin: cudaDeviceAttr = 97;
#[doc = "< Device supports flushing of outstanding remote writes."]
pub const cudaDeviceAttr_cudaDevAttrCanFlushRemoteWrites: cudaDeviceAttr = 98;
#[doc = "< Device supports host memory registration via ::cudaHostRegister."]
pub const cudaDeviceAttr_cudaDevAttrHostRegisterSupported: cudaDeviceAttr = 99;
#[doc = "< Device accesses pageable memory via the host's page tables."]
pub const cudaDeviceAttr_cudaDevAttrPageableMemoryAccessUsesHostPageTables: cudaDeviceAttr = 100;
#[doc = "< Host can directly access managed memory on the device without migration."]
pub const cudaDeviceAttr_cudaDevAttrDirectManagedMemAccessFromHost: cudaDeviceAttr = 101;
#[doc = "< Maximum number of blocks per multiprocessor"]
pub const cudaDeviceAttr_cudaDevAttrMaxBlocksPerMultiprocessor: cudaDeviceAttr = 106;
#[doc = "< Maximum L2 persisting lines capacity setting in bytes."]
pub const cudaDeviceAttr_cudaDevAttrMaxPersistingL2CacheSize: cudaDeviceAttr = 108;
#[doc = "< Maximum value of cudaAccessPolicyWindow::num_bytes."]
pub const cudaDeviceAttr_cudaDevAttrMaxAccessPolicyWindowSize: cudaDeviceAttr = 109;
#[doc = "< Shared memory reserved by CUDA driver per block in bytes"]
pub const cudaDeviceAttr_cudaDevAttrReservedSharedMemoryPerBlock: cudaDeviceAttr = 111;
#[doc = "< Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays"]
pub const cudaDeviceAttr_cudaDevAttrSparseCudaArraySupported: cudaDeviceAttr = 112;
#[doc = "< Device supports using the ::cudaHostRegister flag cudaHostRegisterReadOnly to register memory that must be mapped as read-only to the GPU"]
pub const cudaDeviceAttr_cudaDevAttrHostRegisterReadOnlySupported: cudaDeviceAttr = 113;
#[doc = "< External timeline semaphore interop is supported on the device"]
pub const cudaDeviceAttr_cudaDevAttrMaxTimelineSemaphoreInteropSupported: cudaDeviceAttr = 114;
#[doc = "< Device supports using the ::cudaMallocAsync and ::cudaMemPool family of APIs"]
pub const cudaDeviceAttr_cudaDevAttrMemoryPoolsSupported: cudaDeviceAttr = 115;
#[doc = "< Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see https://docs.nvidia.com/cuda/gpudirect-rdma for more information)"]
pub const cudaDeviceAttr_cudaDevAttrGPUDirectRDMASupported: cudaDeviceAttr = 116;
#[doc = "< The returned attribute shall be interpreted as a bitmask, where the individual bits are listed in the ::cudaFlushGPUDirectRDMAWritesOptions enum"]
pub const cudaDeviceAttr_cudaDevAttrGPUDirectRDMAFlushWritesOptions: cudaDeviceAttr = 117;
#[doc = "< GPUDirect RDMA writes to the device do not need to be flushed for consumers within the scope indicated by the returned attribute. See ::cudaGPUDirectRDMAWritesOrdering for the numerical values returned here."]
pub const cudaDeviceAttr_cudaDevAttrGPUDirectRDMAWritesOrdering: cudaDeviceAttr = 118;
#[doc = "< Handle types supported with mempool based IPC"]
pub const cudaDeviceAttr_cudaDevAttrMemoryPoolSupportedHandleTypes: cudaDeviceAttr = 119;
pub const cudaDeviceAttr_cudaDevAttrMax: cudaDeviceAttr = 120;
#[doc = " CUDA device attributes"]
pub type cudaDeviceAttr = ::std::os::raw::c_uint;
#[doc = " (value type = int)\n Allow cuMemAllocAsync to use memory asynchronously freed\n in another streams as long as a stream ordering dependency\n of the allocating stream on the free action exists.\n Cuda events and null stream interactions can create the required\n stream ordered dependencies. (default enabled)"]
pub const cudaMemPoolAttr_cudaMemPoolReuseFollowEventDependencies: cudaMemPoolAttr = 1;
#[doc = " (value type = int)\n Allow reuse of already completed frees when there is no dependency\n between the free and allocation. (default enabled)"]
pub const cudaMemPoolAttr_cudaMemPoolReuseAllowOpportunistic: cudaMemPoolAttr = 2;
#[doc = " (value type = int)\n Allow cuMemAllocAsync to insert new stream dependencies\n in order to establish the stream ordering required to reuse\n a piece of memory released by cuFreeAsync (default enabled)."]
pub const cudaMemPoolAttr_cudaMemPoolReuseAllowInternalDependencies: cudaMemPoolAttr = 3;
#[doc = " (value type = cuuint64_t)\n Amount of reserved memory in bytes to hold onto before trying\n to release memory back to the OS. When more than the release\n threshold bytes of memory are held by the memory pool, the\n allocator will try to release memory back to the OS on the\n next call to stream, event or context synchronize. (default 0)"]
pub const cudaMemPoolAttr_cudaMemPoolAttrReleaseThreshold: cudaMemPoolAttr = 4;
#[doc = " (value type = cuuint64_t)\n Amount of backing memory currently allocated for the mempool."]
pub const cudaMemPoolAttr_cudaMemPoolAttrReservedMemCurrent: cudaMemPoolAttr = 5;
#[doc = " (value type = cuuint64_t)\n High watermark of backing memory allocated for the mempool since the\n last time it was reset. High watermark can only be reset to zero."]
pub const cudaMemPoolAttr_cudaMemPoolAttrReservedMemHigh: cudaMemPoolAttr = 6;
#[doc = " (value type = cuuint64_t)\n Amount of memory from the pool that is currently in use by the application."]
pub const cudaMemPoolAttr_cudaMemPoolAttrUsedMemCurrent: cudaMemPoolAttr = 7;
#[doc = " (value type = cuuint64_t)\n High watermark of the amount of memory from the pool that was in use by the application since\n the last time it was reset. High watermark can only be reset to zero."]
pub const cudaMemPoolAttr_cudaMemPoolAttrUsedMemHigh: cudaMemPoolAttr = 8;
#[doc = " CUDA memory pool attributes"]
pub type cudaMemPoolAttr = ::std::os::raw::c_uint;
pub const cudaMemLocationType_cudaMemLocationTypeInvalid: cudaMemLocationType = 0;
#[doc = "< Location is a device location, thus id is a device ordinal"]
pub const cudaMemLocationType_cudaMemLocationTypeDevice: cudaMemLocationType = 1;
#[doc = " Specifies the type of location"]
pub type cudaMemLocationType = ::std::os::raw::c_uint;
#[doc = " Specifies a memory location.\n\n To specify a gpu, set type = ::cudaMemLocationTypeDevice and set id = the gpu's device ordinal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemLocation {
    #[doc = "< Specifies the location type, which modifies the meaning of id."]
    pub type_: cudaMemLocationType,
    #[doc = "< identifier for a given this location's ::CUmemLocationType."]
    pub id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cudaMemLocation() {
    const UNINIT: ::std::mem::MaybeUninit<cudaMemLocation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaMemLocation>(),
        8usize,
        concat!("Size of: ", stringify!(cudaMemLocation))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemLocation>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaMemLocation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemLocation),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemLocation),
            "::",
            stringify!(id)
        )
    );
}
#[doc = "< Default, make the address range not accessible"]
pub const cudaMemAccessFlags_cudaMemAccessFlagsProtNone: cudaMemAccessFlags = 0;
#[doc = "< Make the address range read accessible"]
pub const cudaMemAccessFlags_cudaMemAccessFlagsProtRead: cudaMemAccessFlags = 1;
#[doc = "< Make the address range read-write accessible"]
pub const cudaMemAccessFlags_cudaMemAccessFlagsProtReadWrite: cudaMemAccessFlags = 3;
#[doc = " Specifies the memory protection flags for mapping."]
pub type cudaMemAccessFlags = ::std::os::raw::c_uint;
#[doc = " Memory access descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemAccessDesc {
    #[doc = "< Location on which the request is to change it's accessibility"]
    pub location: cudaMemLocation,
    #[doc = "< ::CUmemProt accessibility flags to set on the request"]
    pub flags: cudaMemAccessFlags,
}
#[test]
fn bindgen_test_layout_cudaMemAccessDesc() {
    const UNINIT: ::std::mem::MaybeUninit<cudaMemAccessDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaMemAccessDesc>(),
        12usize,
        concat!("Size of: ", stringify!(cudaMemAccessDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemAccessDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaMemAccessDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAccessDesc),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAccessDesc),
            "::",
            stringify!(flags)
        )
    );
}
pub const cudaMemAllocationType_cudaMemAllocationTypeInvalid: cudaMemAllocationType = 0;
#[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
pub const cudaMemAllocationType_cudaMemAllocationTypePinned: cudaMemAllocationType = 1;
#[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
pub const cudaMemAllocationType_cudaMemAllocationTypeMax: cudaMemAllocationType = 2147483647;
#[doc = " Defines the allocation types available"]
pub type cudaMemAllocationType = ::std::os::raw::c_uint;
#[doc = "< Does not allow any export mechanism. >"]
pub const cudaMemAllocationHandleType_cudaMemHandleTypeNone: cudaMemAllocationHandleType = 0;
#[doc = "< Allows a file descriptor to be used for exporting. Permitted only on POSIX systems. (int)"]
pub const cudaMemAllocationHandleType_cudaMemHandleTypePosixFileDescriptor:
    cudaMemAllocationHandleType = 1;
#[doc = "< Allows a Win32 NT handle to be used for exporting. (HANDLE)"]
pub const cudaMemAllocationHandleType_cudaMemHandleTypeWin32: cudaMemAllocationHandleType = 2;
#[doc = "< Allows a Win32 KMT handle to be used for exporting. (D3DKMT_HANDLE)"]
pub const cudaMemAllocationHandleType_cudaMemHandleTypeWin32Kmt: cudaMemAllocationHandleType = 4;
#[doc = " Flags for specifying particular handle types"]
pub type cudaMemAllocationHandleType = ::std::os::raw::c_uint;
#[doc = " Specifies the properties of allocations made from the pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemPoolProps {
    #[doc = "< Allocation type. Currently must be specified as cudaMemAllocationTypePinned"]
    pub allocType: cudaMemAllocationType,
    #[doc = "< Handle types that will be supported by allocations from the pool."]
    pub handleTypes: cudaMemAllocationHandleType,
    #[doc = "< Location allocations should reside."]
    pub location: cudaMemLocation,
    #[doc = " Windows-specific LPSECURITYATTRIBUTES required when\n ::cudaMemHandleTypeWin32 is specified.  This security attribute defines\n the scope of which exported allocations may be tranferred to other\n processes.  In all other cases, this field is required to be zero."]
    pub win32SecurityAttributes: *mut ::std::os::raw::c_void,
    #[doc = "< reserved for future use, must be 0"]
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cudaMemPoolProps() {
    const UNINIT: ::std::mem::MaybeUninit<cudaMemPoolProps> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaMemPoolProps>(),
        88usize,
        concat!("Size of: ", stringify!(cudaMemPoolProps))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemPoolProps>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemPoolProps))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemPoolProps),
            "::",
            stringify!(allocType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemPoolProps),
            "::",
            stringify!(handleTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemPoolProps),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win32SecurityAttributes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemPoolProps),
            "::",
            stringify!(win32SecurityAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemPoolProps),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Opaque data for exporting a pool allocation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemPoolPtrExportData {
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cudaMemPoolPtrExportData() {
    const UNINIT: ::std::mem::MaybeUninit<cudaMemPoolPtrExportData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaMemPoolPtrExportData>(),
        64usize,
        concat!("Size of: ", stringify!(cudaMemPoolPtrExportData))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemPoolPtrExportData>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaMemPoolPtrExportData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemPoolPtrExportData),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Memory allocation node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemAllocNodeParams {
    #[doc = "< in: array of memory access descriptors. Used to describe peer GPU access"]
    pub poolProps: cudaMemPoolProps,
    #[doc = "< in: number of memory access descriptors.  Must not exceed the number of GPUs."]
    pub accessDescs: *const cudaMemAccessDesc,
    #[doc = "< in: Number of `accessDescs`s"]
    pub accessDescCount: usize,
    #[doc = "< in: size in bytes of the requested allocation"]
    pub bytesize: usize,
    #[doc = "< out: address of the allocation returned by CUDA"]
    pub dptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaMemAllocNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<cudaMemAllocNodeParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaMemAllocNodeParams>(),
        120usize,
        concat!("Size of: ", stringify!(cudaMemAllocNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemAllocNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemAllocNodeParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poolProps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAllocNodeParams),
            "::",
            stringify!(poolProps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessDescs) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAllocNodeParams),
            "::",
            stringify!(accessDescs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessDescCount) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAllocNodeParams),
            "::",
            stringify!(accessDescCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesize) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAllocNodeParams),
            "::",
            stringify!(bytesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dptr) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAllocNodeParams),
            "::",
            stringify!(dptr)
        )
    );
}
#[doc = " (value type = cuuint64_t)\n Amount of memory, in bytes, currently associated with graphs."]
pub const cudaGraphMemAttributeType_cudaGraphMemAttrUsedMemCurrent: cudaGraphMemAttributeType = 1;
#[doc = " (value type = cuuint64_t)\n High watermark of memory, in bytes, associated with graphs since the\n last time it was reset.  High watermark can only be reset to zero."]
pub const cudaGraphMemAttributeType_cudaGraphMemAttrUsedMemHigh: cudaGraphMemAttributeType = 2;
#[doc = " (value type = cuuint64_t)\n Amount of memory, in bytes, currently allocated for use by\n the CUDA graphs asynchronous allocator."]
pub const cudaGraphMemAttributeType_cudaGraphMemAttrReservedMemCurrent: cudaGraphMemAttributeType =
    3;
#[doc = " (value type = cuuint64_t)\n High watermark of memory, in bytes, currently allocated for use by\n the CUDA graphs asynchronous allocator."]
pub const cudaGraphMemAttributeType_cudaGraphMemAttrReservedMemHigh: cudaGraphMemAttributeType = 4;
#[doc = " Graph memory attributes"]
pub type cudaGraphMemAttributeType = ::std::os::raw::c_uint;
#[doc = "< A relative value indicating the performance of the link between two devices"]
pub const cudaDeviceP2PAttr_cudaDevP2PAttrPerformanceRank: cudaDeviceP2PAttr = 1;
#[doc = "< Peer access is enabled"]
pub const cudaDeviceP2PAttr_cudaDevP2PAttrAccessSupported: cudaDeviceP2PAttr = 2;
#[doc = "< Native atomic operation over the link supported"]
pub const cudaDeviceP2PAttr_cudaDevP2PAttrNativeAtomicSupported: cudaDeviceP2PAttr = 3;
#[doc = "< Accessing CUDA arrays over the link supported"]
pub const cudaDeviceP2PAttr_cudaDevP2PAttrCudaArrayAccessSupported: cudaDeviceP2PAttr = 4;
#[doc = " CUDA device P2P attributes"]
pub type cudaDeviceP2PAttr = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuuid_st {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_CUuuid_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUuuid_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUuuid_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUuuid_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUuuid_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUuuid_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUuuid_st),
            "::",
            stringify!(bytes)
        )
    );
}
pub type CUuuid = CUuuid_st;
pub type cudaUUID_t = CUuuid_st;
#[doc = " CUDA device properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaDeviceProp {
    #[doc = "< ASCII string identifying device"]
    pub name: [::std::os::raw::c_char; 256usize],
    #[doc = "< 16-byte unique identifier"]
    pub uuid: cudaUUID_t,
    #[doc = "< 8-byte locally unique identifier. Value is undefined on TCC and non-Windows platforms"]
    pub luid: [::std::os::raw::c_char; 8usize],
    #[doc = "< LUID device node mask. Value is undefined on TCC and non-Windows platforms"]
    pub luidDeviceNodeMask: ::std::os::raw::c_uint,
    #[doc = "< Global memory available on device in bytes"]
    pub totalGlobalMem: usize,
    #[doc = "< Shared memory available per block in bytes"]
    pub sharedMemPerBlock: usize,
    #[doc = "< 32-bit registers available per block"]
    pub regsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Warp size in threads"]
    pub warpSize: ::std::os::raw::c_int,
    #[doc = "< Maximum pitch in bytes allowed by memory copies"]
    pub memPitch: usize,
    #[doc = "< Maximum number of threads per block"]
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Maximum size of each dimension of a block"]
    pub maxThreadsDim: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum size of each dimension of a grid"]
    pub maxGridSize: [::std::os::raw::c_int; 3usize],
    #[doc = "< Clock frequency in kilohertz"]
    pub clockRate: ::std::os::raw::c_int,
    #[doc = "< Constant memory available on device in bytes"]
    pub totalConstMem: usize,
    #[doc = "< Major compute capability"]
    pub major: ::std::os::raw::c_int,
    #[doc = "< Minor compute capability"]
    pub minor: ::std::os::raw::c_int,
    #[doc = "< Alignment requirement for textures"]
    pub textureAlignment: usize,
    #[doc = "< Pitch alignment requirement for texture references bound to pitched memory"]
    pub texturePitchAlignment: usize,
    #[doc = "< Device can concurrently copy memory and execute a kernel. Deprecated. Use instead asyncEngineCount."]
    pub deviceOverlap: ::std::os::raw::c_int,
    #[doc = "< Number of multiprocessors on device"]
    pub multiProcessorCount: ::std::os::raw::c_int,
    #[doc = "< Specified whether there is a run time limit on kernels"]
    pub kernelExecTimeoutEnabled: ::std::os::raw::c_int,
    #[doc = "< Device is integrated as opposed to discrete"]
    pub integrated: ::std::os::raw::c_int,
    #[doc = "< Device can map host memory with cudaHostAlloc/cudaHostGetDevicePointer"]
    pub canMapHostMemory: ::std::os::raw::c_int,
    #[doc = "< Compute mode (See ::cudaComputeMode)"]
    pub computeMode: ::std::os::raw::c_int,
    #[doc = "< Maximum 1D texture size"]
    pub maxTexture1D: ::std::os::raw::c_int,
    #[doc = "< Maximum 1D mipmapped texture size"]
    pub maxTexture1DMipmap: ::std::os::raw::c_int,
    #[doc = "< Deprecated, do not use. Use cudaDeviceGetTexture1DLinearMaxWidth() or cuDeviceGetTexture1DLinearMaxWidth() instead."]
    pub maxTexture1DLinear: ::std::os::raw::c_int,
    #[doc = "< Maximum 2D texture dimensions"]
    pub maxTexture2D: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 2D mipmapped texture dimensions"]
    pub maxTexture2DMipmap: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum dimensions (width, height, pitch) for 2D textures bound to pitched memory"]
    pub maxTexture2DLinear: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum 2D texture dimensions if texture gather operations have to be performed"]
    pub maxTexture2DGather: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 3D texture dimensions"]
    pub maxTexture3D: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum alternate 3D texture dimensions"]
    pub maxTexture3DAlt: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum Cubemap texture dimensions"]
    pub maxTextureCubemap: ::std::os::raw::c_int,
    #[doc = "< Maximum 1D layered texture dimensions"]
    pub maxTexture1DLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 2D layered texture dimensions"]
    pub maxTexture2DLayered: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum Cubemap layered texture dimensions"]
    pub maxTextureCubemapLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 1D surface size"]
    pub maxSurface1D: ::std::os::raw::c_int,
    #[doc = "< Maximum 2D surface dimensions"]
    pub maxSurface2D: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 3D surface dimensions"]
    pub maxSurface3D: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum 1D layered surface dimensions"]
    pub maxSurface1DLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 2D layered surface dimensions"]
    pub maxSurface2DLayered: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum Cubemap surface dimensions"]
    pub maxSurfaceCubemap: ::std::os::raw::c_int,
    #[doc = "< Maximum Cubemap layered surface dimensions"]
    pub maxSurfaceCubemapLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Alignment requirements for surfaces"]
    pub surfaceAlignment: usize,
    #[doc = "< Device can possibly execute multiple kernels concurrently"]
    pub concurrentKernels: ::std::os::raw::c_int,
    #[doc = "< Device has ECC support enabled"]
    pub ECCEnabled: ::std::os::raw::c_int,
    #[doc = "< PCI bus ID of the device"]
    pub pciBusID: ::std::os::raw::c_int,
    #[doc = "< PCI device ID of the device"]
    pub pciDeviceID: ::std::os::raw::c_int,
    #[doc = "< PCI domain ID of the device"]
    pub pciDomainID: ::std::os::raw::c_int,
    #[doc = "< 1 if device is a Tesla device using TCC driver, 0 otherwise"]
    pub tccDriver: ::std::os::raw::c_int,
    #[doc = "< Number of asynchronous engines"]
    pub asyncEngineCount: ::std::os::raw::c_int,
    #[doc = "< Device shares a unified address space with the host"]
    pub unifiedAddressing: ::std::os::raw::c_int,
    #[doc = "< Peak memory clock frequency in kilohertz"]
    pub memoryClockRate: ::std::os::raw::c_int,
    #[doc = "< Global memory bus width in bits"]
    pub memoryBusWidth: ::std::os::raw::c_int,
    #[doc = "< Size of L2 cache in bytes"]
    pub l2CacheSize: ::std::os::raw::c_int,
    #[doc = "< Device's maximum l2 persisting lines capacity setting in bytes"]
    pub persistingL2CacheMaxSize: ::std::os::raw::c_int,
    #[doc = "< Maximum resident threads per multiprocessor"]
    pub maxThreadsPerMultiProcessor: ::std::os::raw::c_int,
    #[doc = "< Device supports stream priorities"]
    pub streamPrioritiesSupported: ::std::os::raw::c_int,
    #[doc = "< Device supports caching globals in L1"]
    pub globalL1CacheSupported: ::std::os::raw::c_int,
    #[doc = "< Device supports caching locals in L1"]
    pub localL1CacheSupported: ::std::os::raw::c_int,
    #[doc = "< Shared memory available per multiprocessor in bytes"]
    pub sharedMemPerMultiprocessor: usize,
    #[doc = "< 32-bit registers available per multiprocessor"]
    pub regsPerMultiprocessor: ::std::os::raw::c_int,
    #[doc = "< Device supports allocating managed memory on this system"]
    pub managedMemory: ::std::os::raw::c_int,
    #[doc = "< Device is on a multi-GPU board"]
    pub isMultiGpuBoard: ::std::os::raw::c_int,
    #[doc = "< Unique identifier for a group of devices on the same multi-GPU board"]
    pub multiGpuBoardGroupID: ::std::os::raw::c_int,
    #[doc = "< Link between the device and the host supports native atomic operations"]
    pub hostNativeAtomicSupported: ::std::os::raw::c_int,
    #[doc = "< Ratio of single precision performance (in floating-point operations per second) to double precision performance"]
    pub singleToDoublePrecisionPerfRatio: ::std::os::raw::c_int,
    #[doc = "< Device supports coherently accessing pageable memory without calling cudaHostRegister on it"]
    pub pageableMemoryAccess: ::std::os::raw::c_int,
    #[doc = "< Device can coherently access managed memory concurrently with the CPU"]
    pub concurrentManagedAccess: ::std::os::raw::c_int,
    #[doc = "< Device supports Compute Preemption"]
    pub computePreemptionSupported: ::std::os::raw::c_int,
    #[doc = "< Device can access host registered memory at the same virtual address as the CPU"]
    pub canUseHostPointerForRegisteredMem: ::std::os::raw::c_int,
    #[doc = "< Device supports launching cooperative kernels via ::cudaLaunchCooperativeKernel"]
    pub cooperativeLaunch: ::std::os::raw::c_int,
    #[doc = "< Deprecated, cudaLaunchCooperativeKernelMultiDevice is deprecated."]
    pub cooperativeMultiDeviceLaunch: ::std::os::raw::c_int,
    #[doc = "< Per device maximum shared memory per block usable by special opt in"]
    pub sharedMemPerBlockOptin: usize,
    #[doc = "< Device accesses pageable memory via the host's page tables"]
    pub pageableMemoryAccessUsesHostPageTables: ::std::os::raw::c_int,
    #[doc = "< Host can directly access managed memory on the device without migration."]
    pub directManagedMemAccessFromHost: ::std::os::raw::c_int,
    #[doc = "< Maximum number of resident blocks per multiprocessor"]
    pub maxBlocksPerMultiProcessor: ::std::os::raw::c_int,
    #[doc = "< The maximum value of ::cudaAccessPolicyWindow::num_bytes."]
    pub accessPolicyMaxWindowSize: ::std::os::raw::c_int,
    #[doc = "< Shared memory reserved by CUDA driver per block in bytes"]
    pub reservedSharedMemPerBlock: usize,
}
#[test]
fn bindgen_test_layout_cudaDeviceProp() {
    const UNINIT: ::std::mem::MaybeUninit<cudaDeviceProp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaDeviceProp>(),
        728usize,
        concat!("Size of: ", stringify!(cudaDeviceProp))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaDeviceProp>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaDeviceProp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).luid) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(luid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).luidDeviceNodeMask) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(luidDeviceNodeMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalGlobalMem) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(totalGlobalMem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemPerBlock) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(sharedMemPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regsPerBlock) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(regsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).warpSize) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(warpSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memPitch) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(memPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxThreadsPerBlock) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxThreadsDim) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxThreadsDim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxGridSize) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxGridSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clockRate) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(clockRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalConstMem) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(totalConstMem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).textureAlignment) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(textureAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).texturePitchAlignment) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(texturePitchAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceOverlap) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(deviceOverlap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multiProcessorCount) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(multiProcessorCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kernelExecTimeoutEnabled) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(kernelExecTimeoutEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integrated) as usize - ptr as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(integrated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).canMapHostMemory) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(canMapHostMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).computeMode) as usize - ptr as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(computeMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture1D) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture1D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture1DMipmap) as usize - ptr as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture1DMipmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture1DLinear) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture1DLinear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture2D) as usize - ptr as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture2DMipmap) as usize - ptr as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2DMipmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture2DLinear) as usize - ptr as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2DLinear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture2DGather) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2DGather)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture3D) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture3D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture3DAlt) as usize - ptr as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture3DAlt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTextureCubemap) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTextureCubemap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture1DLayered) as usize - ptr as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture1DLayered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture2DLayered) as usize - ptr as usize },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2DLayered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTextureCubemapLayered) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTextureCubemapLayered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurface1D) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface1D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurface2D) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface2D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurface3D) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface3D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurface1DLayered) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface1DLayered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurface2DLayered) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface2DLayered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurfaceCubemap) as usize - ptr as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurfaceCubemap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurfaceCubemapLayered) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurfaceCubemapLayered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).surfaceAlignment) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(surfaceAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).concurrentKernels) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(concurrentKernels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ECCEnabled) as usize - ptr as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(ECCEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciBusID) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pciBusID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciDeviceID) as usize - ptr as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pciDeviceID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciDomainID) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pciDomainID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tccDriver) as usize - ptr as usize },
        596usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(tccDriver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asyncEngineCount) as usize - ptr as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(asyncEngineCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unifiedAddressing) as usize - ptr as usize },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(unifiedAddressing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryClockRate) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(memoryClockRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryBusWidth) as usize - ptr as usize },
        612usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(memoryBusWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l2CacheSize) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(l2CacheSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).persistingL2CacheMaxSize) as usize - ptr as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(persistingL2CacheMaxSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxThreadsPerMultiProcessor) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxThreadsPerMultiProcessor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamPrioritiesSupported) as usize - ptr as usize },
        628usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(streamPrioritiesSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).globalL1CacheSupported) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(globalL1CacheSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localL1CacheSupported) as usize - ptr as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(localL1CacheSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemPerMultiprocessor) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(sharedMemPerMultiprocessor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regsPerMultiprocessor) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(regsPerMultiprocessor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).managedMemory) as usize - ptr as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(managedMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isMultiGpuBoard) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(isMultiGpuBoard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multiGpuBoardGroupID) as usize - ptr as usize },
        660usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(multiGpuBoardGroupID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostNativeAtomicSupported) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(hostNativeAtomicSupported)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).singleToDoublePrecisionPerfRatio) as usize - ptr as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(singleToDoublePrecisionPerfRatio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pageableMemoryAccess) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pageableMemoryAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).concurrentManagedAccess) as usize - ptr as usize },
        676usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(concurrentManagedAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).computePreemptionSupported) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(computePreemptionSupported)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).canUseHostPointerForRegisteredMem) as usize - ptr as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(canUseHostPointerForRegisteredMem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cooperativeLaunch) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(cooperativeLaunch)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).cooperativeMultiDeviceLaunch) as usize - ptr as usize
        },
        692usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(cooperativeMultiDeviceLaunch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemPerBlockOptin) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(sharedMemPerBlockOptin)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pageableMemoryAccessUsesHostPageTables) as usize
                - ptr as usize
        },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pageableMemoryAccessUsesHostPageTables)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).directManagedMemAccessFromHost) as usize - ptr as usize
        },
        708usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(directManagedMemAccessFromHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxBlocksPerMultiProcessor) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxBlocksPerMultiProcessor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessPolicyMaxWindowSize) as usize - ptr as usize },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(accessPolicyMaxWindowSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedSharedMemPerBlock) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(reservedSharedMemPerBlock)
        )
    );
}
#[doc = " CUDA IPC event handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaIpcEventHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_cudaIpcEventHandle_st() {
    const UNINIT: ::std::mem::MaybeUninit<cudaIpcEventHandle_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaIpcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(cudaIpcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaIpcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaIpcEventHandle_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaIpcEventHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " CUDA IPC event handle"]
pub type cudaIpcEventHandle_t = cudaIpcEventHandle_st;
#[doc = " CUDA IPC memory handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaIpcMemHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_cudaIpcMemHandle_st() {
    const UNINIT: ::std::mem::MaybeUninit<cudaIpcMemHandle_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaIpcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(cudaIpcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaIpcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaIpcMemHandle_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaIpcMemHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " CUDA IPC memory handle"]
pub type cudaIpcMemHandle_t = cudaIpcMemHandle_st;
#[doc = " Handle is an opaque file descriptor"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeOpaqueFd:
    cudaExternalMemoryHandleType = 1;
#[doc = " Handle is an opaque shared NT handle"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeOpaqueWin32:
    cudaExternalMemoryHandleType = 2;
#[doc = " Handle is an opaque, globally shared handle"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeOpaqueWin32Kmt:
    cudaExternalMemoryHandleType = 3;
#[doc = " Handle is a D3D12 heap object"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D12Heap:
    cudaExternalMemoryHandleType = 4;
#[doc = " Handle is a D3D12 committed resource"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D12Resource:
    cudaExternalMemoryHandleType = 5;
#[doc = "  Handle is a shared NT handle to a D3D11 resource"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D11Resource:
    cudaExternalMemoryHandleType = 6;
#[doc = "  Handle is a globally shared handle to a D3D11 resource"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D11ResourceKmt:
    cudaExternalMemoryHandleType = 7;
#[doc = "  Handle is an NvSciBuf object"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeNvSciBuf:
    cudaExternalMemoryHandleType = 8;
#[doc = " External memory handle types"]
pub type cudaExternalMemoryHandleType = ::std::os::raw::c_uint;
#[doc = " External memory handle descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalMemoryHandleDesc {
    #[doc = " Type of the handle"]
    pub type_: cudaExternalMemoryHandleType,
    pub handle: cudaExternalMemoryHandleDesc__bindgen_ty_1,
    #[doc = " Size of the memory allocation"]
    pub size: ::std::os::raw::c_ulonglong,
    #[doc = " Flags must either be zero or ::cudaExternalMemoryDedicated"]
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalMemoryHandleDesc__bindgen_ty_1 {
    #[doc = " File descriptor referencing the memory object. Valid\n when type is\n ::cudaExternalMemoryHandleTypeOpaqueFd"]
    pub fd: ::std::os::raw::c_int,
    pub win32: cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
    #[doc = " A handle representing NvSciBuf Object. Valid when type\n is ::cudaExternalMemoryHandleTypeNvSciBuf"]
    pub nvSciBufObject: *const ::std::os::raw::c_void,
}
#[doc = " Win32 handle referencing the semaphore object. Valid when\n type is one of the following:\n - ::cudaExternalMemoryHandleTypeOpaqueWin32\n - ::cudaExternalMemoryHandleTypeOpaqueWin32Kmt\n - ::cudaExternalMemoryHandleTypeD3D12Heap\n - ::cudaExternalMemoryHandleTypeD3D12Resource\n - ::cudaExternalMemoryHandleTypeD3D11Resource\n - ::cudaExternalMemoryHandleTypeD3D11ResourceKmt\n Exactly one of 'handle' and 'name' must be non-NULL. If\n type is one of the following:\n ::cudaExternalMemoryHandleTypeOpaqueWin32Kmt\n ::cudaExternalMemoryHandleTypeD3D11ResourceKmt\n then 'name' must be NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Valid NT handle. Must be NULL if 'name' is non-NULL"]
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " Name of a valid memory object.\n Must be NULL if 'handle' is non-NULL."]
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<cudaExternalMemoryHandleDesc__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvSciBufObject) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
            "::",
            stringify!(nvSciBufObject)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc() {
    const UNINIT: ::std::mem::MaybeUninit<cudaExternalMemoryHandleDesc> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc>(),
        40usize,
        concat!("Size of: ", stringify!(cudaExternalMemoryHandleDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalMemoryHandleDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " External memory buffer descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryBufferDesc {
    #[doc = " Offset into the memory object where the buffer's base is"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = " Size of the buffer"]
    pub size: ::std::os::raw::c_ulonglong,
    #[doc = " Flags reserved for future use. Must be zero."]
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryBufferDesc() {
    const UNINIT: ::std::mem::MaybeUninit<cudaExternalMemoryBufferDesc> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryBufferDesc>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExternalMemoryBufferDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryBufferDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalMemoryBufferDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryBufferDesc),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryBufferDesc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryBufferDesc),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " External memory mipmap descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryMipmappedArrayDesc {
    #[doc = " Offset into the memory object where the base level of the\n mipmap chain is."]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = " Format of base level of the mipmap chain"]
    pub formatDesc: cudaChannelFormatDesc,
    #[doc = " Dimensions of base level of the mipmap chain"]
    pub extent: cudaExtent,
    #[doc = " Flags associated with CUDA mipmapped arrays.\n See ::cudaMallocMipmappedArray"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = " Total number of levels in the mipmap chain"]
    pub numLevels: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryMipmappedArrayDesc() {
    const UNINIT: ::std::mem::MaybeUninit<cudaExternalMemoryMipmappedArrayDesc> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryMipmappedArrayDesc>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryMipmappedArrayDesc>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).formatDesc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(formatDesc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numLevels) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(numLevels)
        )
    );
}
#[doc = " Handle is an opaque file descriptor"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeOpaqueFd:
    cudaExternalSemaphoreHandleType = 1;
#[doc = " Handle is an opaque shared NT handle"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeOpaqueWin32:
    cudaExternalSemaphoreHandleType = 2;
#[doc = " Handle is an opaque, globally shared handle"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt:
    cudaExternalSemaphoreHandleType = 3;
#[doc = " Handle is a shared NT handle referencing a D3D12 fence object"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeD3D12Fence:
    cudaExternalSemaphoreHandleType = 4;
#[doc = " Handle is a shared NT handle referencing a D3D11 fence object"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeD3D11Fence:
    cudaExternalSemaphoreHandleType = 5;
#[doc = " Opaque handle to NvSciSync Object"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeNvSciSync:
    cudaExternalSemaphoreHandleType = 6;
#[doc = " Handle is a shared NT handle referencing a D3D11 keyed mutex object"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeKeyedMutex:
    cudaExternalSemaphoreHandleType = 7;
#[doc = " Handle is a shared KMT handle referencing a D3D11 keyed mutex object"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeKeyedMutexKmt:
    cudaExternalSemaphoreHandleType = 8;
#[doc = " Handle is an opaque handle file descriptor referencing a timeline semaphore"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd:
    cudaExternalSemaphoreHandleType = 9;
#[doc = " Handle is an opaque handle file descriptor referencing a timeline semaphore"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32:
    cudaExternalSemaphoreHandleType = 10;
#[doc = " External semaphore handle types"]
pub type cudaExternalSemaphoreHandleType = ::std::os::raw::c_uint;
#[doc = " External semaphore handle descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreHandleDesc {
    #[doc = " Type of the handle"]
    pub type_: cudaExternalSemaphoreHandleType,
    pub handle: cudaExternalSemaphoreHandleDesc__bindgen_ty_1,
    #[doc = " Flags reserved for the future. Must be zero."]
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreHandleDesc__bindgen_ty_1 {
    #[doc = " File descriptor referencing the semaphore object. Valid when\n type is one of the following:\n - ::cudaExternalSemaphoreHandleTypeOpaqueFd\n - ::cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd"]
    pub fd: ::std::os::raw::c_int,
    pub win32: cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
    #[doc = " Valid NvSciSyncObj. Must be non NULL"]
    pub nvSciSyncObj: *const ::std::os::raw::c_void,
}
#[doc = " Win32 handle referencing the semaphore object. Valid when\n type is one of the following:\n - ::cudaExternalSemaphoreHandleTypeOpaqueWin32\n - ::cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt\n - ::cudaExternalSemaphoreHandleTypeD3D12Fence\n - ::cudaExternalSemaphoreHandleTypeD3D11Fence\n - ::cudaExternalSemaphoreHandleTypeKeyedMutex\n - ::cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32\n Exactly one of 'handle' and 'name' must be non-NULL. If\n type is one of the following:\n ::cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt\n ::cudaExternalSemaphoreHandleTypeKeyedMutexKmt\n then 'name' must be NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Valid NT handle. Must be NULL if 'name' is non-NULL"]
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " Name of a valid synchronization primitive.\n Must be NULL if 'handle' is non-NULL."]
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<cudaExternalSemaphoreHandleDesc__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvSciSyncObj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
            "::",
            stringify!(nvSciSyncObj)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc() {
    const UNINIT: ::std::mem::MaybeUninit<cudaExternalSemaphoreHandleDesc> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc>(),
        32usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreHandleDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalSemaphoreHandleDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " External semaphore signal parameters, compatible with driver type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams {
    pub params: cudaExternalSemaphoreSignalParams__bindgen_ty_1,
    #[doc = " Only when ::cudaExternalSemaphoreSignalParams is used to\n signal a ::cudaExternalSemaphore_t of type\n ::cudaExternalSemaphoreHandleTypeNvSciSync, the valid flag is\n ::cudaExternalSemaphoreSignalSkipNvSciBufMemSync: which indicates\n that while signaling the ::cudaExternalSemaphore_t, no memory\n synchronization operations should be performed for any external memory\n object imported as ::cudaExternalMemoryHandleTypeNvSciBuf.\n For all other types of ::cudaExternalSemaphore_t, flags must be zero."]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 12usize],
}
#[doc = " Parameters for fence objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be signaled"]
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Pointer to NvSciSyncFence. Valid if ::cudaExternalSemaphoreHandleType\n is of type ::cudaExternalSemaphoreHandleTypeNvSciSync."]
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Parameters for keyed mutex objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<
        cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<cudaExternalSemaphoreSignalParams__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams() {
    const UNINIT: ::std::mem::MaybeUninit<cudaExternalSemaphoreSignalParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams>(),
        144usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreSignalParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " External semaphore wait parameters, compatible with driver type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams {
    pub params: cudaExternalSemaphoreWaitParams__bindgen_ty_1,
    #[doc = " Only when ::cudaExternalSemaphoreSignalParams is used to\n signal a ::cudaExternalSemaphore_t of type\n ::cudaExternalSemaphoreHandleTypeNvSciSync, the valid flag is\n ::cudaExternalSemaphoreSignalSkipNvSciBufMemSync: which indicates\n that while waiting for the ::cudaExternalSemaphore_t, no memory\n synchronization operations should be performed for any external memory\n object imported as ::cudaExternalMemoryHandleTypeNvSciBuf.\n For all other types of ::cudaExternalSemaphore_t, flags must be zero."]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 10usize],
}
#[doc = " Parameters for fence objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be waited on"]
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Pointer to NvSciSyncFence. Valid if ::cudaExternalSemaphoreHandleType\n is of type ::cudaExternalSemaphoreHandleTypeNvSciSync."]
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Parameters for keyed mutex objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Value of key to acquire the mutex with"]
    pub key: ::std::os::raw::c_ulonglong,
    #[doc = " Timeout in milliseconds to wait to acquire the mutex"]
    pub timeoutMs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<
        cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeoutMs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(timeoutMs)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<cudaExternalSemaphoreWaitParams__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams() {
    const UNINIT: ::std::mem::MaybeUninit<cudaExternalSemaphoreWaitParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams>(),
        144usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalSemaphoreWaitParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " CUDA error types"]
pub use self::cudaError as cudaError_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
#[doc = " CUDA stream"]
pub type cudaStream_t = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
#[doc = " CUDA event types"]
pub type cudaEvent_t = *mut CUevent_st;
#[doc = " CUDA graphics resource types"]
pub type cudaGraphicsResource_t = *mut cudaGraphicsResource;
#[doc = " CUDA Profiler Output modes"]
pub use self::cudaOutputMode as cudaOutputMode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexternalMemory_st {
    _unused: [u8; 0],
}
#[doc = " CUDA external memory"]
pub type cudaExternalMemory_t = *mut CUexternalMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexternalSemaphore_st {
    _unused: [u8; 0],
}
#[doc = " CUDA external semaphore"]
pub type cudaExternalSemaphore_t = *mut CUexternalSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
#[doc = " CUDA graph"]
pub type cudaGraph_t = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
#[doc = " CUDA graph node."]
pub type cudaGraphNode_t = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuserObject_st {
    _unused: [u8; 0],
}
#[doc = " CUDA user object for graphs"]
pub type cudaUserObject_t = *mut CUuserObject_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
#[doc = " CUDA function"]
pub type cudaFunction_t = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolHandle_st {
    _unused: [u8; 0],
}
#[doc = " CUDA memory pool"]
pub type cudaMemPool_t = *mut CUmemPoolHandle_st;
#[doc = "< Invalid cooperative group scope"]
pub const cudaCGScope_cudaCGScopeInvalid: cudaCGScope = 0;
#[doc = "< Scope represented by a grid_group"]
pub const cudaCGScope_cudaCGScopeGrid: cudaCGScope = 1;
#[doc = "< Scope represented by a multi_grid_group"]
pub const cudaCGScope_cudaCGScopeMultiGrid: cudaCGScope = 2;
#[doc = " CUDA cooperative group scope"]
pub type cudaCGScope = ::std::os::raw::c_uint;
#[doc = " CUDA launch parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaLaunchParams {
    #[doc = "< Device function symbol"]
    pub func: *mut ::std::os::raw::c_void,
    #[doc = "< Grid dimentions"]
    pub gridDim: dim3,
    #[doc = "< Block dimentions"]
    pub blockDim: dim3,
    #[doc = "< Arguments"]
    pub args: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Shared memory"]
    pub sharedMem: usize,
    #[doc = "< Stream identifier"]
    pub stream: cudaStream_t,
}
#[test]
fn bindgen_test_layout_cudaLaunchParams() {
    const UNINIT: ::std::mem::MaybeUninit<cudaLaunchParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaLaunchParams>(),
        56usize,
        concat!("Size of: ", stringify!(cudaLaunchParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaLaunchParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaLaunchParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDim) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(gridDim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDim) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(blockDim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMem) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(sharedMem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(stream)
        )
    );
}
#[doc = " CUDA GPU kernel node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaKernelNodeParams {
    #[doc = "< Kernel to launch"]
    pub func: *mut ::std::os::raw::c_void,
    #[doc = "< Grid dimensions"]
    pub gridDim: dim3,
    #[doc = "< Block dimensions"]
    pub blockDim: dim3,
    #[doc = "< Dynamic shared-memory size per thread block in bytes"]
    pub sharedMemBytes: ::std::os::raw::c_uint,
    #[doc = "< Array of pointers to individual kernel arguments"]
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to kernel arguments in the \"extra\" format"]
    pub extra: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaKernelNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<cudaKernelNodeParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaKernelNodeParams>(),
        56usize,
        concat!("Size of: ", stringify!(cudaKernelNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaKernelNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaKernelNodeParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDim) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(gridDim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDim) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(blockDim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(kernelParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(extra)
        )
    );
}
#[doc = " External semaphore signal node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalNodeParams {
    #[doc = "< Array of external semaphore handles."]
    pub extSemArray: *mut cudaExternalSemaphore_t,
    #[doc = "< Array of external semaphore signal parameters."]
    pub paramsArray: *const cudaExternalSemaphoreSignalParams,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray."]
    pub numExtSems: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<cudaExternalSemaphoreSignalNodeParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalNodeParams>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalNodeParams)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalNodeParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalNodeParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalNodeParams),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalNodeParams),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalNodeParams),
            "::",
            stringify!(numExtSems)
        )
    );
}
#[doc = " External semaphore wait node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitNodeParams {
    #[doc = "< Array of external semaphore handles."]
    pub extSemArray: *mut cudaExternalSemaphore_t,
    #[doc = "< Array of external semaphore wait parameters."]
    pub paramsArray: *const cudaExternalSemaphoreWaitParams,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray."]
    pub numExtSems: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<cudaExternalSemaphoreWaitNodeParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitNodeParams>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitNodeParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitNodeParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitNodeParams),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitNodeParams),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitNodeParams),
            "::",
            stringify!(numExtSems)
        )
    );
}
#[doc = "< GPU kernel node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeKernel: cudaGraphNodeType = 0;
#[doc = "< Memcpy node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeMemcpy: cudaGraphNodeType = 1;
#[doc = "< Memset node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeMemset: cudaGraphNodeType = 2;
#[doc = "< Host (executable) node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeHost: cudaGraphNodeType = 3;
#[doc = "< Node which executes an embedded graph"]
pub const cudaGraphNodeType_cudaGraphNodeTypeGraph: cudaGraphNodeType = 4;
#[doc = "< Empty (no-op) node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeEmpty: cudaGraphNodeType = 5;
#[doc = "< External event wait node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeWaitEvent: cudaGraphNodeType = 6;
#[doc = "< External event record node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeEventRecord: cudaGraphNodeType = 7;
#[doc = "< External semaphore signal node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeExtSemaphoreSignal: cudaGraphNodeType = 8;
#[doc = "< External semaphore wait node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeExtSemaphoreWait: cudaGraphNodeType = 9;
#[doc = "< Memory allocation node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeMemAlloc: cudaGraphNodeType = 10;
#[doc = "< Memory free node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeMemFree: cudaGraphNodeType = 11;
pub const cudaGraphNodeType_cudaGraphNodeTypeCount: cudaGraphNodeType = 12;
#[doc = " CUDA Graph node types"]
pub type cudaGraphNodeType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
#[doc = " CUDA executable (launchable) graph"]
pub type cudaGraphExec_t = *mut CUgraphExec_st;
#[doc = "< The update succeeded"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateSuccess: cudaGraphExecUpdateResult = 0;
#[doc = "< The update failed for an unexpected reason which is described in the return value of the function"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateError: cudaGraphExecUpdateResult = 1;
#[doc = "< The update failed because the topology changed"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorTopologyChanged:
    cudaGraphExecUpdateResult = 2;
#[doc = "< The update failed because a node type changed"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorNodeTypeChanged:
    cudaGraphExecUpdateResult = 3;
#[doc = "< The update failed because the function of a kernel node changed (CUDA driver < 11.2)"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorFunctionChanged:
    cudaGraphExecUpdateResult = 4;
#[doc = "< The update failed because the parameters changed in a way that is not supported"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorParametersChanged:
    cudaGraphExecUpdateResult = 5;
#[doc = "< The update failed because something about the node is not supported"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorNotSupported:
    cudaGraphExecUpdateResult = 6;
#[doc = "< The update failed because the function of a kernel node changed in an unsupported way"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorUnsupportedFunctionChange:
    cudaGraphExecUpdateResult = 7;
#[doc = " CUDA Graph Update error types"]
pub type cudaGraphExecUpdateResult = ::std::os::raw::c_uint;
#[doc = "< Default search mode for driver symbols."]
pub const cudaGetDriverEntryPointFlags_cudaEnableDefault: cudaGetDriverEntryPointFlags = 0;
#[doc = "< Search for legacy versions of driver symbols."]
pub const cudaGetDriverEntryPointFlags_cudaEnableLegacyStream: cudaGetDriverEntryPointFlags = 1;
#[doc = "< Search for per-thread versions of driver symbols."]
pub const cudaGetDriverEntryPointFlags_cudaEnablePerThreadDefaultStream:
    cudaGetDriverEntryPointFlags = 2;
#[doc = " Flags to specify search options to be used with ::cudaGetDriverEntryPoint\n For more details see ::cuGetProcAddress"]
pub type cudaGetDriverEntryPointFlags = ::std::os::raw::c_uint;
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsVerbose: cudaGraphDebugDotFlags = 1;
#[doc = " Output all debug data as if every debug flag is enabled"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsKernelNodeParams: cudaGraphDebugDotFlags = 4;
#[doc = " Adds cudaKernelNodeParams to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsMemcpyNodeParams: cudaGraphDebugDotFlags = 8;
#[doc = " Adds cudaMemcpy3DParms to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsMemsetNodeParams: cudaGraphDebugDotFlags =
    16;
#[doc = " Adds cudaMemsetParams to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsHostNodeParams: cudaGraphDebugDotFlags = 32;
#[doc = " Adds cudaHostNodeParams to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsEventNodeParams: cudaGraphDebugDotFlags = 64;
#[doc = " Adds cudaEvent_t handle from record and wait nodes to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsExtSemasSignalNodeParams:
    cudaGraphDebugDotFlags = 128;
#[doc = " Adds cudaExternalSemaphoreSignalNodeParams values to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsExtSemasWaitNodeParams:
    cudaGraphDebugDotFlags = 256;
#[doc = " Adds cudaExternalSemaphoreWaitNodeParams to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsKernelNodeAttributes:
    cudaGraphDebugDotFlags = 512;
#[doc = " Adds cudaKernelNodeAttrID values to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsHandles: cudaGraphDebugDotFlags = 1024;
#[doc = " CUDA Graph debug write options"]
pub type cudaGraphDebugDotFlags = ::std::os::raw::c_uint;
#[doc = "< Automatically free memory allocated in a graph before relaunching."]
pub const cudaGraphInstantiateFlags_cudaGraphInstantiateFlagAutoFreeOnLaunch:
    cudaGraphInstantiateFlags = 1;
#[doc = " Flags for instantiating a graph"]
pub type cudaGraphInstantiateFlags = ::std::os::raw::c_uint;
#[doc = " Types which allow static initialization of \"half\" and \"half2\" until\n these become an actual builtin. Note this initialization is as a\n bitfield representation of \"half\", and not a conversion from short->half.\n Such a representation will be deprecated in a future version of CUDA.\n (Note these are visible to non-nvcc compilers, including C-only compilation)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __half_raw {
    pub x: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout___half_raw() {
    const UNINIT: ::std::mem::MaybeUninit<__half_raw> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__half_raw>(),
        2usize,
        concat!("Size of: ", stringify!(__half_raw))
    );
    assert_eq!(
        ::std::mem::align_of::<__half_raw>(),
        2usize,
        concat!("Alignment of ", stringify!(__half_raw))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__half_raw),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __half2_raw {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout___half2_raw() {
    const UNINIT: ::std::mem::MaybeUninit<__half2_raw> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__half2_raw>(),
        4usize,
        concat!("Size of: ", stringify!(__half2_raw))
    );
    assert_eq!(
        ::std::mem::align_of::<__half2_raw>(),
        4usize,
        concat!("Alignment of ", stringify!(__half2_raw))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__half2_raw),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__half2_raw),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " Types which allow static initialization of \"nv_bfloat16\" and \"nv_bfloat162\" until\n these become an actual builtin. Note this initialization is as a\n bitfield representation of \"nv_bfloat16\", and not a conversion from short->nv_bfloat16.\n Such a representation will be deprecated in a future version of CUDA.\n (Note these are visible to non-nvcc compilers, including C-only compilation)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __nv_bfloat16_raw {
    pub x: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout___nv_bfloat16_raw() {
    const UNINIT: ::std::mem::MaybeUninit<__nv_bfloat16_raw> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__nv_bfloat16_raw>(),
        2usize,
        concat!("Size of: ", stringify!(__nv_bfloat16_raw))
    );
    assert_eq!(
        ::std::mem::align_of::<__nv_bfloat16_raw>(),
        2usize,
        concat!("Alignment of ", stringify!(__nv_bfloat16_raw))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__nv_bfloat16_raw),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __nv_bfloat162_raw {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout___nv_bfloat162_raw() {
    const UNINIT: ::std::mem::MaybeUninit<__nv_bfloat162_raw> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__nv_bfloat162_raw>(),
        4usize,
        concat!("Size of: ", stringify!(__nv_bfloat162_raw))
    );
    assert_eq!(
        ::std::mem::align_of::<__nv_bfloat162_raw>(),
        4usize,
        concat!("Alignment of ", stringify!(__nv_bfloat162_raw))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__nv_bfloat162_raw),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__nv_bfloat162_raw),
            "::",
            stringify!(y)
        )
    );
}
pub const cudaDataType_t_CUDA_R_16F: cudaDataType_t = 2;
pub const cudaDataType_t_CUDA_C_16F: cudaDataType_t = 6;
pub const cudaDataType_t_CUDA_R_16BF: cudaDataType_t = 14;
pub const cudaDataType_t_CUDA_C_16BF: cudaDataType_t = 15;
pub const cudaDataType_t_CUDA_R_32F: cudaDataType_t = 0;
pub const cudaDataType_t_CUDA_C_32F: cudaDataType_t = 4;
pub const cudaDataType_t_CUDA_R_64F: cudaDataType_t = 1;
pub const cudaDataType_t_CUDA_C_64F: cudaDataType_t = 5;
pub const cudaDataType_t_CUDA_R_4I: cudaDataType_t = 16;
pub const cudaDataType_t_CUDA_C_4I: cudaDataType_t = 17;
pub const cudaDataType_t_CUDA_R_4U: cudaDataType_t = 18;
pub const cudaDataType_t_CUDA_C_4U: cudaDataType_t = 19;
pub const cudaDataType_t_CUDA_R_8I: cudaDataType_t = 3;
pub const cudaDataType_t_CUDA_C_8I: cudaDataType_t = 7;
pub const cudaDataType_t_CUDA_R_8U: cudaDataType_t = 8;
pub const cudaDataType_t_CUDA_C_8U: cudaDataType_t = 9;
pub const cudaDataType_t_CUDA_R_16I: cudaDataType_t = 20;
pub const cudaDataType_t_CUDA_C_16I: cudaDataType_t = 21;
pub const cudaDataType_t_CUDA_R_16U: cudaDataType_t = 22;
pub const cudaDataType_t_CUDA_C_16U: cudaDataType_t = 23;
pub const cudaDataType_t_CUDA_R_32I: cudaDataType_t = 10;
pub const cudaDataType_t_CUDA_C_32I: cudaDataType_t = 11;
pub const cudaDataType_t_CUDA_R_32U: cudaDataType_t = 12;
pub const cudaDataType_t_CUDA_C_32U: cudaDataType_t = 13;
pub const cudaDataType_t_CUDA_R_64I: cudaDataType_t = 24;
pub const cudaDataType_t_CUDA_C_64I: cudaDataType_t = 25;
pub const cudaDataType_t_CUDA_R_64U: cudaDataType_t = 26;
pub const cudaDataType_t_CUDA_C_64U: cudaDataType_t = 27;
pub type cudaDataType_t = ::std::os::raw::c_uint;
pub use self::cudaDataType_t as cudaDataType;
pub const libraryPropertyType_t_MAJOR_VERSION: libraryPropertyType_t = 0;
pub const libraryPropertyType_t_MINOR_VERSION: libraryPropertyType_t = 1;
pub const libraryPropertyType_t_PATCH_LEVEL: libraryPropertyType_t = 2;
pub type libraryPropertyType_t = ::std::os::raw::c_uint;
pub use self::libraryPropertyType_t as libraryPropertyType;
pub const cublasStatus_t_CUBLAS_STATUS_SUCCESS: cublasStatus_t = 0;
pub const cublasStatus_t_CUBLAS_STATUS_NOT_INITIALIZED: cublasStatus_t = 1;
pub const cublasStatus_t_CUBLAS_STATUS_ALLOC_FAILED: cublasStatus_t = 3;
pub const cublasStatus_t_CUBLAS_STATUS_INVALID_VALUE: cublasStatus_t = 7;
pub const cublasStatus_t_CUBLAS_STATUS_ARCH_MISMATCH: cublasStatus_t = 8;
pub const cublasStatus_t_CUBLAS_STATUS_MAPPING_ERROR: cublasStatus_t = 11;
pub const cublasStatus_t_CUBLAS_STATUS_EXECUTION_FAILED: cublasStatus_t = 13;
pub const cublasStatus_t_CUBLAS_STATUS_INTERNAL_ERROR: cublasStatus_t = 14;
pub const cublasStatus_t_CUBLAS_STATUS_NOT_SUPPORTED: cublasStatus_t = 15;
pub const cublasStatus_t_CUBLAS_STATUS_LICENSE_ERROR: cublasStatus_t = 16;
pub type cublasStatus_t = ::std::os::raw::c_uint;
pub const cublasFillMode_t_CUBLAS_FILL_MODE_LOWER: cublasFillMode_t = 0;
pub const cublasFillMode_t_CUBLAS_FILL_MODE_UPPER: cublasFillMode_t = 1;
pub const cublasFillMode_t_CUBLAS_FILL_MODE_FULL: cublasFillMode_t = 2;
pub type cublasFillMode_t = ::std::os::raw::c_uint;
pub const cublasDiagType_t_CUBLAS_DIAG_NON_UNIT: cublasDiagType_t = 0;
pub const cublasDiagType_t_CUBLAS_DIAG_UNIT: cublasDiagType_t = 1;
pub type cublasDiagType_t = ::std::os::raw::c_uint;
pub const cublasSideMode_t_CUBLAS_SIDE_LEFT: cublasSideMode_t = 0;
pub const cublasSideMode_t_CUBLAS_SIDE_RIGHT: cublasSideMode_t = 1;
pub type cublasSideMode_t = ::std::os::raw::c_uint;
pub const cublasOperation_t_CUBLAS_OP_N: cublasOperation_t = 0;
pub const cublasOperation_t_CUBLAS_OP_T: cublasOperation_t = 1;
pub const cublasOperation_t_CUBLAS_OP_C: cublasOperation_t = 2;
pub const cublasOperation_t_CUBLAS_OP_HERMITAN: cublasOperation_t = 2;
pub const cublasOperation_t_CUBLAS_OP_CONJG: cublasOperation_t = 3;
pub type cublasOperation_t = ::std::os::raw::c_uint;
pub const cublasPointerMode_t_CUBLAS_POINTER_MODE_HOST: cublasPointerMode_t = 0;
pub const cublasPointerMode_t_CUBLAS_POINTER_MODE_DEVICE: cublasPointerMode_t = 1;
pub type cublasPointerMode_t = ::std::os::raw::c_uint;
pub const cublasAtomicsMode_t_CUBLAS_ATOMICS_NOT_ALLOWED: cublasAtomicsMode_t = 0;
pub const cublasAtomicsMode_t_CUBLAS_ATOMICS_ALLOWED: cublasAtomicsMode_t = 1;
pub type cublasAtomicsMode_t = ::std::os::raw::c_uint;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_DFALT: cublasGemmAlgo_t = -1;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_DEFAULT: cublasGemmAlgo_t = -1;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO0: cublasGemmAlgo_t = 0;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO1: cublasGemmAlgo_t = 1;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO2: cublasGemmAlgo_t = 2;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO3: cublasGemmAlgo_t = 3;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO4: cublasGemmAlgo_t = 4;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO5: cublasGemmAlgo_t = 5;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO6: cublasGemmAlgo_t = 6;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO7: cublasGemmAlgo_t = 7;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO8: cublasGemmAlgo_t = 8;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO9: cublasGemmAlgo_t = 9;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO10: cublasGemmAlgo_t = 10;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO11: cublasGemmAlgo_t = 11;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO12: cublasGemmAlgo_t = 12;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO13: cublasGemmAlgo_t = 13;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO14: cublasGemmAlgo_t = 14;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO15: cublasGemmAlgo_t = 15;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO16: cublasGemmAlgo_t = 16;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO17: cublasGemmAlgo_t = 17;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO18: cublasGemmAlgo_t = 18;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO19: cublasGemmAlgo_t = 19;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO20: cublasGemmAlgo_t = 20;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO21: cublasGemmAlgo_t = 21;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO22: cublasGemmAlgo_t = 22;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO23: cublasGemmAlgo_t = 23;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_DEFAULT_TENSOR_OP: cublasGemmAlgo_t = 99;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_DFALT_TENSOR_OP: cublasGemmAlgo_t = 99;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO0_TENSOR_OP: cublasGemmAlgo_t = 100;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO1_TENSOR_OP: cublasGemmAlgo_t = 101;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO2_TENSOR_OP: cublasGemmAlgo_t = 102;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO3_TENSOR_OP: cublasGemmAlgo_t = 103;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO4_TENSOR_OP: cublasGemmAlgo_t = 104;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO5_TENSOR_OP: cublasGemmAlgo_t = 105;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO6_TENSOR_OP: cublasGemmAlgo_t = 106;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO7_TENSOR_OP: cublasGemmAlgo_t = 107;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO8_TENSOR_OP: cublasGemmAlgo_t = 108;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO9_TENSOR_OP: cublasGemmAlgo_t = 109;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO10_TENSOR_OP: cublasGemmAlgo_t = 110;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO11_TENSOR_OP: cublasGemmAlgo_t = 111;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO12_TENSOR_OP: cublasGemmAlgo_t = 112;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO13_TENSOR_OP: cublasGemmAlgo_t = 113;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO14_TENSOR_OP: cublasGemmAlgo_t = 114;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO15_TENSOR_OP: cublasGemmAlgo_t = 115;
pub type cublasGemmAlgo_t = ::std::os::raw::c_int;
pub const cublasMath_t_CUBLAS_DEFAULT_MATH: cublasMath_t = 0;
pub const cublasMath_t_CUBLAS_TENSOR_OP_MATH: cublasMath_t = 1;
pub const cublasMath_t_CUBLAS_PEDANTIC_MATH: cublasMath_t = 2;
pub const cublasMath_t_CUBLAS_TF32_TENSOR_OP_MATH: cublasMath_t = 3;
pub const cublasMath_t_CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION: cublasMath_t = 16;
pub type cublasMath_t = ::std::os::raw::c_uint;
pub use self::cudaDataType as cublasDataType_t;
pub const cublasComputeType_t_CUBLAS_COMPUTE_16F: cublasComputeType_t = 64;
pub const cublasComputeType_t_CUBLAS_COMPUTE_16F_PEDANTIC: cublasComputeType_t = 65;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32F: cublasComputeType_t = 68;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32F_PEDANTIC: cublasComputeType_t = 69;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32F_FAST_16F: cublasComputeType_t = 74;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32F_FAST_16BF: cublasComputeType_t = 75;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32F_FAST_TF32: cublasComputeType_t = 77;
pub const cublasComputeType_t_CUBLAS_COMPUTE_64F: cublasComputeType_t = 70;
pub const cublasComputeType_t_CUBLAS_COMPUTE_64F_PEDANTIC: cublasComputeType_t = 71;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32I: cublasComputeType_t = 72;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32I_PEDANTIC: cublasComputeType_t = 73;
pub type cublasComputeType_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cublasContext {
    _unused: [u8; 0],
}
pub type cublasHandle_t = *mut cublasContext;
extern "C" {
    pub fn cublasCreate_v2(handle: *mut cublasHandle_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDestroy_v2(handle: cublasHandle_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetVersion_v2(
        handle: cublasHandle_t,
        version: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetProperty(
        type_: libraryPropertyType,
        value: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetCudartVersion() -> usize;
}
extern "C" {
    pub fn cublasSetWorkspace_v2(
        handle: cublasHandle_t,
        workspace: *mut ::std::os::raw::c_void,
        workspaceSizeInBytes: usize,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetStream_v2(handle: cublasHandle_t, streamId: cudaStream_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetStream_v2(
        handle: cublasHandle_t,
        streamId: *mut cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetPointerMode_v2(
        handle: cublasHandle_t,
        mode: *mut cublasPointerMode_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetPointerMode_v2(
        handle: cublasHandle_t,
        mode: cublasPointerMode_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetAtomicsMode(
        handle: cublasHandle_t,
        mode: *mut cublasAtomicsMode_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetAtomicsMode(
        handle: cublasHandle_t,
        mode: cublasAtomicsMode_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetMathMode(handle: cublasHandle_t, mode: *mut cublasMath_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetMathMode(handle: cublasHandle_t, mode: cublasMath_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetSmCountTarget(
        handle: cublasHandle_t,
        smCountTarget: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetSmCountTarget(
        handle: cublasHandle_t,
        smCountTarget: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
pub type cublasLogCallback =
    ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn cublasLoggerConfigure(
        logIsOn: ::std::os::raw::c_int,
        logToStdOut: ::std::os::raw::c_int,
        logToStdErr: ::std::os::raw::c_int,
        logFileName: *const ::std::os::raw::c_char,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetLoggerCallback(userCallback: cublasLogCallback) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetLoggerCallback(userCallback: *mut cublasLogCallback) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetVector(
        n: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        incx: ::std::os::raw::c_int,
        devicePtr: *mut ::std::os::raw::c_void,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetVector(
        n: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetMatrix(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        A: *const ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetMatrix(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        A: *const ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetVectorAsync(
        n: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        hostPtr: *const ::std::os::raw::c_void,
        incx: ::std::os::raw::c_int,
        devicePtr: *mut ::std::os::raw::c_void,
        incy: ::std::os::raw::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetVectorAsync(
        n: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        devicePtr: *const ::std::os::raw::c_void,
        incx: ::std::os::raw::c_int,
        hostPtr: *mut ::std::os::raw::c_void,
        incy: ::std::os::raw::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetMatrixAsync(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        A: *const ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetMatrixAsync(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        A: *const ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasXerbla(srName: *const ::std::os::raw::c_char, info: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cublasNrm2Ex(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: cudaDataType,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSnrm2_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDnrm2_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasScnrm2_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDznrm2_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDotEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *const ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: cudaDataType,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDotcEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *const ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: cudaDataType,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSdot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDdot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCdotu_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        result: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCdotc_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        result: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdotu_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        result: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdotc_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        result: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasScalEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: cudaDataType,
        x: *mut ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSscal_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDscal_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCscal_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsscal_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZscal_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdscal_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasAxpyEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: cudaDataType,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSaxpy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDaxpy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCaxpy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZaxpy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCopyEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasScopy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDcopy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCcopy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZcopy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSswap_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDswap_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCswap_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZswap_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSwapEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIsamax_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIdamax_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIcamax_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIzamax_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIamaxEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIsamin_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIdamin_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIcamin_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIzamin_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIaminEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasAsumEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSasum_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDasum_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasScasum_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDzasum_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSrot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDrot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCrot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsrot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZrot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdrot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasRotEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        csType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSrotg_v2(
        handle: cublasHandle_t,
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        s: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDrotg_v2(
        handle: cublasHandle_t,
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        s: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCrotg_v2(
        handle: cublasHandle_t,
        a: *mut cuComplex,
        b: *mut cuComplex,
        c: *mut f32,
        s: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZrotg_v2(
        handle: cublasHandle_t,
        a: *mut cuDoubleComplex,
        b: *mut cuDoubleComplex,
        c: *mut f64,
        s: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasRotgEx(
        handle: cublasHandle_t,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        abType: cudaDataType,
        c: *mut ::std::os::raw::c_void,
        s: *mut ::std::os::raw::c_void,
        csType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSrotm_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        param: *const f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDrotm_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        param: *const f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasRotmEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
        param: *const ::std::os::raw::c_void,
        paramType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSrotmg_v2(
        handle: cublasHandle_t,
        d1: *mut f32,
        d2: *mut f32,
        x1: *mut f32,
        y1: *const f32,
        param: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDrotmg_v2(
        handle: cublasHandle_t,
        d1: *mut f64,
        d2: *mut f64,
        x1: *mut f64,
        y1: *const f64,
        param: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasRotmgEx(
        handle: cublasHandle_t,
        d1: *mut ::std::os::raw::c_void,
        d1Type: cudaDataType,
        d2: *mut ::std::os::raw::c_void,
        d2Type: cudaDataType,
        x1: *mut ::std::os::raw::c_void,
        x1Type: cudaDataType,
        y1: *const ::std::os::raw::c_void,
        y1Type: cudaDataType,
        param: *mut ::std::os::raw::c_void,
        paramType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const cuComplex,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const cuDoubleComplex,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const cuComplex,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const cuDoubleComplex,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChemv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhemv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSspmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDspmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        AP: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        AP: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSger_v2(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDger_v2(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgeru_v2(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgerc_v2(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgeru_v2(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgerc_v2(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCher_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZher_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSspr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        AP: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDspr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        AP: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChpr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhpr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCher2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZher2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSspr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        AP: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDspr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        AP: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChpr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhpr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm3m(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm3mEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_void,
        Btype: cudaDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemm3m(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemmEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_void,
        Btype: cudaDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGemmEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_void,
        Btype: cudaDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
        computeType: cublasComputeType_t,
        algo: cublasGemmAlgo_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemmEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_void,
        Btype: cudaDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasUint8gemmBias(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        transc: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const ::std::os::raw::c_uchar,
        A_bias: ::std::os::raw::c_int,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_uchar,
        B_bias: ::std::os::raw::c_int,
        ldb: ::std::os::raw::c_int,
        C: *mut ::std::os::raw::c_uchar,
        C_bias: ::std::os::raw::c_int,
        ldc: ::std::os::raw::c_int,
        C_mult: ::std::os::raw::c_int,
        C_shift: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyrkEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyrk3mEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCherk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZherk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCherkEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCherk3mEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCher2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZher2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCherkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZherkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChemm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhemm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuComplex,
        ldb: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        Aarray: *const *const f32,
        lda: ::std::os::raw::c_int,
        Barray: *const *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        Carray: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        Aarray: *const *const f64,
        lda: ::std::os::raw::c_int,
        Barray: *const *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        Carray: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        Aarray: *const *const cuComplex,
        lda: ::std::os::raw::c_int,
        Barray: *const *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        Carray: *const *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm3mBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        Aarray: *const *const cuComplex,
        lda: ::std::os::raw::c_int,
        Barray: *const *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        Carray: *const *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        Aarray: *const *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Barray: *const *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        Carray: *const *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGemmBatchedEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        Aarray: *const *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        Barray: *const *const ::std::os::raw::c_void,
        Btype: cudaDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const ::std::os::raw::c_void,
        Carray: *const *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        computeType: cublasComputeType_t,
        algo: cublasGemmAlgo_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGemmStridedBatchedEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        B: *const ::std::os::raw::c_void,
        Btype: cudaDataType,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
        computeType: cublasComputeType_t,
        algo: cublasGemmAlgo_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm3mStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        beta: *const cuComplex,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgetrfBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut f32,
        lda: ::std::os::raw::c_int,
        P: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgetrfBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut f64,
        lda: ::std::os::raw::c_int,
        P: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgetrfBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut cuComplex,
        lda: ::std::os::raw::c_int,
        P: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgetrfBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        P: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgetriBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const f32,
        lda: ::std::os::raw::c_int,
        P: *const ::std::os::raw::c_int,
        C: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgetriBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const f64,
        lda: ::std::os::raw::c_int,
        P: *const ::std::os::raw::c_int,
        C: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgetriBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const cuComplex,
        lda: ::std::os::raw::c_int,
        P: *const ::std::os::raw::c_int,
        C: *const *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgetriBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        P: *const ::std::os::raw::c_int,
        C: *const *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *const f32,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        Barray: *const *mut f32,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *const f64,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        Barray: *const *mut f64,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *const cuComplex,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        Barray: *const *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        Barray: *const *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::std::os::raw::c_int,
        B: *const *mut f32,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::std::os::raw::c_int,
        B: *const *mut f64,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSmatinvBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const f32,
        lda: ::std::os::raw::c_int,
        Ainv: *const *mut f32,
        lda_inv: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDmatinvBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const f64,
        lda: ::std::os::raw::c_int,
        Ainv: *const *mut f64,
        lda_inv: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCmatinvBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const cuComplex,
        lda: ::std::os::raw::c_int,
        Ainv: *const *mut cuComplex,
        lda_inv: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZmatinvBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Ainv: *const *mut cuDoubleComplex,
        lda_inv: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgeqrfBatched(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Aarray: *const *mut f32,
        lda: ::std::os::raw::c_int,
        TauArray: *const *mut f32,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgeqrfBatched(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Aarray: *const *mut f64,
        lda: ::std::os::raw::c_int,
        TauArray: *const *mut f64,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgeqrfBatched(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Aarray: *const *mut cuComplex,
        lda: ::std::os::raw::c_int,
        TauArray: *const *mut cuComplex,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgeqrfBatched(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Aarray: *const *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        TauArray: *const *mut cuDoubleComplex,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *mut f32,
        lda: ::std::os::raw::c_int,
        Carray: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        devInfoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *mut f64,
        lda: ::std::os::raw::c_int,
        Carray: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        devInfoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *mut cuComplex,
        lda: ::std::os::raw::c_int,
        Carray: *const *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        devInfoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Carray: *const *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        devInfoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        AP: *const f32,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        AP: *const f64,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        AP: *const cuComplex,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        AP: *const cuDoubleComplex,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        AP: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        AP: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        AP: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        AP: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type cusolver_int_t = ::std::os::raw::c_int;
pub const cusolverStatus_t_CUSOLVER_STATUS_SUCCESS: cusolverStatus_t = 0;
pub const cusolverStatus_t_CUSOLVER_STATUS_NOT_INITIALIZED: cusolverStatus_t = 1;
pub const cusolverStatus_t_CUSOLVER_STATUS_ALLOC_FAILED: cusolverStatus_t = 2;
pub const cusolverStatus_t_CUSOLVER_STATUS_INVALID_VALUE: cusolverStatus_t = 3;
pub const cusolverStatus_t_CUSOLVER_STATUS_ARCH_MISMATCH: cusolverStatus_t = 4;
pub const cusolverStatus_t_CUSOLVER_STATUS_MAPPING_ERROR: cusolverStatus_t = 5;
pub const cusolverStatus_t_CUSOLVER_STATUS_EXECUTION_FAILED: cusolverStatus_t = 6;
pub const cusolverStatus_t_CUSOLVER_STATUS_INTERNAL_ERROR: cusolverStatus_t = 7;
pub const cusolverStatus_t_CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED: cusolverStatus_t = 8;
pub const cusolverStatus_t_CUSOLVER_STATUS_NOT_SUPPORTED: cusolverStatus_t = 9;
pub const cusolverStatus_t_CUSOLVER_STATUS_ZERO_PIVOT: cusolverStatus_t = 10;
pub const cusolverStatus_t_CUSOLVER_STATUS_INVALID_LICENSE: cusolverStatus_t = 11;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED: cusolverStatus_t = 12;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_PARAMS_INVALID: cusolverStatus_t = 13;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_PARAMS_INVALID_PREC: cusolverStatus_t = 14;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_PARAMS_INVALID_REFINE: cusolverStatus_t = 15;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_PARAMS_INVALID_MAXITER: cusolverStatus_t = 16;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_INTERNAL_ERROR: cusolverStatus_t = 20;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_NOT_SUPPORTED: cusolverStatus_t = 21;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_OUT_OF_RANGE: cusolverStatus_t = 22;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_NRHS_NOT_SUPPORTED_FOR_REFINE_GMRES:
    cusolverStatus_t = 23;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED: cusolverStatus_t = 25;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_INFOS_NOT_DESTROYED: cusolverStatus_t = 26;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_MATRIX_SINGULAR: cusolverStatus_t = 30;
pub const cusolverStatus_t_CUSOLVER_STATUS_INVALID_WORKSPACE: cusolverStatus_t = 31;
pub type cusolverStatus_t = ::std::os::raw::c_uint;
pub const cusolverEigType_t_CUSOLVER_EIG_TYPE_1: cusolverEigType_t = 1;
pub const cusolverEigType_t_CUSOLVER_EIG_TYPE_2: cusolverEigType_t = 2;
pub const cusolverEigType_t_CUSOLVER_EIG_TYPE_3: cusolverEigType_t = 3;
pub type cusolverEigType_t = ::std::os::raw::c_uint;
pub const cusolverEigMode_t_CUSOLVER_EIG_MODE_NOVECTOR: cusolverEigMode_t = 0;
pub const cusolverEigMode_t_CUSOLVER_EIG_MODE_VECTOR: cusolverEigMode_t = 1;
pub type cusolverEigMode_t = ::std::os::raw::c_uint;
pub const cusolverEigRange_t_CUSOLVER_EIG_RANGE_ALL: cusolverEigRange_t = 1001;
pub const cusolverEigRange_t_CUSOLVER_EIG_RANGE_I: cusolverEigRange_t = 1002;
pub const cusolverEigRange_t_CUSOLVER_EIG_RANGE_V: cusolverEigRange_t = 1003;
pub type cusolverEigRange_t = ::std::os::raw::c_uint;
pub const cusolverNorm_t_CUSOLVER_INF_NORM: cusolverNorm_t = 104;
pub const cusolverNorm_t_CUSOLVER_MAX_NORM: cusolverNorm_t = 105;
pub const cusolverNorm_t_CUSOLVER_ONE_NORM: cusolverNorm_t = 106;
pub const cusolverNorm_t_CUSOLVER_FRO_NORM: cusolverNorm_t = 107;
pub type cusolverNorm_t = ::std::os::raw::c_uint;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_NOT_SET: cusolverIRSRefinement_t = 1100;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_NONE: cusolverIRSRefinement_t = 1101;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_CLASSICAL: cusolverIRSRefinement_t = 1102;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_CLASSICAL_GMRES: cusolverIRSRefinement_t =
    1103;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_GMRES: cusolverIRSRefinement_t = 1104;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_GMRES_GMRES: cusolverIRSRefinement_t = 1105;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_GMRES_NOPCOND: cusolverIRSRefinement_t = 1106;
pub const cusolverIRSRefinement_t_CUSOLVER_PREC_DD: cusolverIRSRefinement_t = 1150;
pub const cusolverIRSRefinement_t_CUSOLVER_PREC_SS: cusolverIRSRefinement_t = 1151;
pub const cusolverIRSRefinement_t_CUSOLVER_PREC_SHT: cusolverIRSRefinement_t = 1152;
pub type cusolverIRSRefinement_t = ::std::os::raw::c_uint;
pub const cusolverPrecType_t_CUSOLVER_R_8I: cusolverPrecType_t = 1201;
pub const cusolverPrecType_t_CUSOLVER_R_8U: cusolverPrecType_t = 1202;
pub const cusolverPrecType_t_CUSOLVER_R_64F: cusolverPrecType_t = 1203;
pub const cusolverPrecType_t_CUSOLVER_R_32F: cusolverPrecType_t = 1204;
pub const cusolverPrecType_t_CUSOLVER_R_16F: cusolverPrecType_t = 1205;
pub const cusolverPrecType_t_CUSOLVER_R_16BF: cusolverPrecType_t = 1206;
pub const cusolverPrecType_t_CUSOLVER_R_TF32: cusolverPrecType_t = 1207;
pub const cusolverPrecType_t_CUSOLVER_R_AP: cusolverPrecType_t = 1208;
pub const cusolverPrecType_t_CUSOLVER_C_8I: cusolverPrecType_t = 1211;
pub const cusolverPrecType_t_CUSOLVER_C_8U: cusolverPrecType_t = 1212;
pub const cusolverPrecType_t_CUSOLVER_C_64F: cusolverPrecType_t = 1213;
pub const cusolverPrecType_t_CUSOLVER_C_32F: cusolverPrecType_t = 1214;
pub const cusolverPrecType_t_CUSOLVER_C_16F: cusolverPrecType_t = 1215;
pub const cusolverPrecType_t_CUSOLVER_C_16BF: cusolverPrecType_t = 1216;
pub const cusolverPrecType_t_CUSOLVER_C_TF32: cusolverPrecType_t = 1217;
pub const cusolverPrecType_t_CUSOLVER_C_AP: cusolverPrecType_t = 1218;
pub type cusolverPrecType_t = ::std::os::raw::c_uint;
pub const cusolverAlgMode_t_CUSOLVER_ALG_0: cusolverAlgMode_t = 0;
pub const cusolverAlgMode_t_CUSOLVER_ALG_1: cusolverAlgMode_t = 1;
pub type cusolverAlgMode_t = ::std::os::raw::c_uint;
pub const cusolverStorevMode_t_CUBLAS_STOREV_COLUMNWISE: cusolverStorevMode_t = 0;
pub const cusolverStorevMode_t_CUBLAS_STOREV_ROWWISE: cusolverStorevMode_t = 1;
pub type cusolverStorevMode_t = ::std::os::raw::c_uint;
pub const cusolverDirectMode_t_CUBLAS_DIRECT_FORWARD: cusolverDirectMode_t = 0;
pub const cusolverDirectMode_t_CUBLAS_DIRECT_BACKWARD: cusolverDirectMode_t = 1;
pub type cusolverDirectMode_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn cusolverGetProperty(
        type_: libraryPropertyType,
        value: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverGetVersion(version: *mut ::std::os::raw::c_int) -> cusolverStatus_t;
}
#[link(name = "cusolver")]
extern "C" {
    pub fn cusolverDnCreate(handle: *mut cusolverDnHandle_t) -> cusolverStatus_t;
}
#[link(name = "cusolver")]
extern "C" {
    pub fn cusolverDnDestroy(handle: cusolverDnHandle_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSetStream(
        handle: cusolverDnHandle_t,
        streamId: cudaStream_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnGetStream(
        handle: cusolverDnHandle_t,
        streamId: *mut cudaStream_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSParamsCreate(params_ptr: *mut cusolverDnIRSParams_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSParamsDestroy(params: cusolverDnIRSParams_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSParamsSetRefinementSolver(
        params: cusolverDnIRSParams_t,
        refinement_solver: cusolverIRSRefinement_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSParamsSetSolverMainPrecision(
        params: cusolverDnIRSParams_t,
        solver_main_precision: cusolverPrecType_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSParamsSetSolverLowestPrecision(
        params: cusolverDnIRSParams_t,
        solver_lowest_precision: cusolverPrecType_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSParamsSetSolverPrecisions(
        params: cusolverDnIRSParams_t,
        solver_main_precision: cusolverPrecType_t,
        solver_lowest_precision: cusolverPrecType_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSParamsSetTol(params: cusolverDnIRSParams_t, val: f64) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSParamsSetTolInner(
        params: cusolverDnIRSParams_t,
        val: f64,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSParamsSetMaxIters(
        params: cusolverDnIRSParams_t,
        maxiters: cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSParamsSetMaxItersInner(
        params: cusolverDnIRSParams_t,
        maxiters_inner: cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSParamsGetMaxIters(
        params: cusolverDnIRSParams_t,
        maxiters: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSParamsEnableFallback(params: cusolverDnIRSParams_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSParamsDisableFallback(params: cusolverDnIRSParams_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSInfosDestroy(infos: cusolverDnIRSInfos_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSInfosCreate(infos_ptr: *mut cusolverDnIRSInfos_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSInfosGetNiters(
        infos: cusolverDnIRSInfos_t,
        niters: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSInfosGetOuterNiters(
        infos: cusolverDnIRSInfos_t,
        outer_niters: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSInfosRequestResidual(infos: cusolverDnIRSInfos_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSInfosGetResidualHistory(
        infos: cusolverDnIRSInfos_t,
        residual_history: *mut *mut ::std::os::raw::c_void,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSInfosGetMaxIters(
        infos: cusolverDnIRSInfos_t,
        maxiters: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZZgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZCgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZKgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZEgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZYgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCCgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCEgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCKgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCYgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDDgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDSgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDHgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDBgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDXgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSSgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSHgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSBgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSXgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZZgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZCgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZKgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZEgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZYgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCCgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCKgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCEgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCYgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDDgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDSgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDHgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDBgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDXgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSSgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSHgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSBgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSXgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZZgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZCgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZKgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZEgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZYgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCCgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCKgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCEgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCYgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDDgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDSgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDHgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDBgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDXgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSSgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSHgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSBgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSXgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZZgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZCgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZKgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZEgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZYgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCCgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCKgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCEgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCYgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDDgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDSgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDHgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDBgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDXgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSSgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSHgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSBgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSXgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSXgesv(
        handle: cusolverDnHandle_t,
        gesv_irs_params: cusolverDnIRSParams_t,
        gesv_irs_infos: cusolverDnIRSInfos_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut ::std::os::raw::c_void,
        ldda: cusolver_int_t,
        dB: *mut ::std::os::raw::c_void,
        lddb: cusolver_int_t,
        dX: *mut ::std::os::raw::c_void,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        niters: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSXgesv_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnIRSParams_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSXgels(
        handle: cusolverDnHandle_t,
        gels_irs_params: cusolverDnIRSParams_t,
        gels_irs_infos: cusolverDnIRSInfos_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut ::std::os::raw::c_void,
        ldda: cusolver_int_t,
        dB: *mut ::std::os::raw::c_void,
        lddb: cusolver_int_t,
        dX: *mut ::std::os::raw::c_void,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        niters: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnIRSXgels_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnIRSParams_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSpotrf_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDpotrf_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCpotrf_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZpotrf_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSpotrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        Workspace: *mut f32,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDpotrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        Workspace: *mut f64,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCpotrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        Workspace: *mut cuComplex,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZpotrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Workspace: *mut cuDoubleComplex,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSpotrs(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDpotrs(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCpotrs(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZpotrs(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSpotrfBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        Aarray: *mut *mut f32,
        lda: ::std::os::raw::c_int,
        infoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDpotrfBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        Aarray: *mut *mut f64,
        lda: ::std::os::raw::c_int,
        infoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCpotrfBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        Aarray: *mut *mut cuComplex,
        lda: ::std::os::raw::c_int,
        infoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZpotrfBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        Aarray: *mut *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        infoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSpotrsBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut *mut f32,
        lda: ::std::os::raw::c_int,
        B: *mut *mut f32,
        ldb: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDpotrsBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut *mut f64,
        lda: ::std::os::raw::c_int,
        B: *mut *mut f64,
        ldb: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCpotrsBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut *mut cuComplex,
        lda: ::std::os::raw::c_int,
        B: *mut *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZpotrsBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSpotri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDpotri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCpotri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZpotri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSpotri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDpotri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCpotri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZpotri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXtrtri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        diag: cublasDiagType_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXtrtri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        diag: cublasDiagType_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSlauum_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDlauum_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnClauum_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZlauum_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSlauum(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDlauum(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnClauum(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZlauum(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgetrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgetrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgetrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgetrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgetrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        Workspace: *mut f32,
        devIpiv: *mut ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgetrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        Workspace: *mut f64,
        devIpiv: *mut ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgetrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        Workspace: *mut cuComplex,
        devIpiv: *mut ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgetrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Workspace: *mut cuDoubleComplex,
        devIpiv: *mut ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSlaswp(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        k1: ::std::os::raw::c_int,
        k2: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        incx: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDlaswp(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        k1: ::std::os::raw::c_int,
        k2: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        incx: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnClaswp(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        k1: ::std::os::raw::c_int,
        k2: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        incx: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZlaswp(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        k1: ::std::os::raw::c_int,
        k2: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        incx: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgetrs(
        handle: cusolverDnHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgetrs(
        handle: cusolverDnHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgetrs(
        handle: cusolverDnHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        B: *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgetrs(
        handle: cusolverDnHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgeqrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgeqrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgeqrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgeqrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgeqrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        TAU: *mut f32,
        Workspace: *mut f32,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgeqrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        TAU: *mut f64,
        Workspace: *mut f64,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgeqrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        TAU: *mut cuComplex,
        Workspace: *mut cuComplex,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgeqrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        TAU: *mut cuDoubleComplex,
        Workspace: *mut cuDoubleComplex,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSorgqr_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDorgqr_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCungqr_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZungqr_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSorgqr(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDorgqr(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCungqr(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZungqr(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSormqr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        C: *const f32,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDormqr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        C: *const f64,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCunmqr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        C: *const cuComplex,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZunmqr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        C: *const cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSormqr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDormqr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCunmqr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZunmqr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsytrf_bufferSize(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsytrf_bufferSize(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCsytrf_bufferSize(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZsytrf_bufferSize(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsytrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsytrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCsytrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZsytrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXsytrs_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: i64,
        nrhs: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        ipiv: *const i64,
        dataTypeB: cudaDataType,
        B: *mut ::std::os::raw::c_void,
        ldb: i64,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXsytrs(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: i64,
        nrhs: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        ipiv: *const i64,
        dataTypeB: cudaDataType,
        B: *mut ::std::os::raw::c_void,
        ldb: i64,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsytri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsytri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCsytri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZsytri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsytri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsytri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCsytri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZsytri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgebrd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgebrd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgebrd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgebrd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgebrd(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        D: *mut f32,
        E: *mut f32,
        TAUQ: *mut f32,
        TAUP: *mut f32,
        Work: *mut f32,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgebrd(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        D: *mut f64,
        E: *mut f64,
        TAUQ: *mut f64,
        TAUP: *mut f64,
        Work: *mut f64,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgebrd(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        D: *mut f32,
        E: *mut f32,
        TAUQ: *mut cuComplex,
        TAUP: *mut cuComplex,
        Work: *mut cuComplex,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgebrd(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        D: *mut f64,
        E: *mut f64,
        TAUQ: *mut cuDoubleComplex,
        TAUP: *mut cuDoubleComplex,
        Work: *mut cuDoubleComplex,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSorgbr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDorgbr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCungbr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZungbr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSorgbr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDorgbr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCungbr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZungbr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsytrd_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        d: *const f32,
        e: *const f32,
        tau: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsytrd_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        d: *const f64,
        e: *const f64,
        tau: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnChetrd_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        d: *const f32,
        e: *const f32,
        tau: *const cuComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZhetrd_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        d: *const f64,
        e: *const f64,
        tau: *const cuDoubleComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsytrd(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        d: *mut f32,
        e: *mut f32,
        tau: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsytrd(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tau: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnChetrd(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        d: *mut f32,
        e: *mut f32,
        tau: *mut cuComplex,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZhetrd(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tau: *mut cuDoubleComplex,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSorgtr_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDorgtr_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCungtr_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZungtr_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSorgtr(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDorgtr(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCungtr(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZungtr(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSormtr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        C: *const f32,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDormtr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        C: *const f64,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCunmtr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        C: *const cuComplex,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZunmtr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        C: *const cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSormtr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        tau: *mut f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDormtr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        tau: *mut f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCunmtr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *mut cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZunmtr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *mut cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgesvd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgesvd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgesvd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgesvd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgesvd(
        handle: cusolverDnHandle_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        S: *mut f32,
        U: *mut f32,
        ldu: ::std::os::raw::c_int,
        VT: *mut f32,
        ldvt: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        rwork: *mut f32,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgesvd(
        handle: cusolverDnHandle_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        S: *mut f64,
        U: *mut f64,
        ldu: ::std::os::raw::c_int,
        VT: *mut f64,
        ldvt: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgesvd(
        handle: cusolverDnHandle_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        S: *mut f32,
        U: *mut cuComplex,
        ldu: ::std::os::raw::c_int,
        VT: *mut cuComplex,
        ldvt: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        rwork: *mut f32,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgesvd(
        handle: cusolverDnHandle_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        S: *mut f64,
        U: *mut cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        VT: *mut cuDoubleComplex,
        ldvt: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsyevd_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsyevd_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCheevd_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZheevd_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsyevd(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsyevd(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCheevd(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZheevd(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsyevdx_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsyevdx_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCheevdx_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZheevdx_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsyevdx(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsyevdx(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCheevdx(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZheevdx(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsygvdx_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsygvdx_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnChegvdx_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZhegvdx_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsygvdx(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsygvdx(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnChegvdx(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZhegvdx(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsygvd_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsygvd_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnChegvd_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZhegvd_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsygvd(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsygvd(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnChegvd(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZhegvd(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCreateSyevjInfo(info: *mut syevjInfo_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDestroySyevjInfo(info: syevjInfo_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXsyevjSetTolerance(info: syevjInfo_t, tolerance: f64) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXsyevjSetMaxSweeps(
        info: syevjInfo_t,
        max_sweeps: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXsyevjSetSortEig(
        info: syevjInfo_t,
        sort_eig: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXsyevjGetResidual(
        handle: cusolverDnHandle_t,
        info: syevjInfo_t,
        residual: *mut f64,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXsyevjGetSweeps(
        handle: cusolverDnHandle_t,
        info: syevjInfo_t,
        executed_sweeps: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsyevjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsyevjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCheevjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZheevjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsyevjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsyevjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCheevjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZheevjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsyevj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsyevj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCheevj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZheevj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsyevj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsyevj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCheevj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZheevj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsygvj_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsygvj_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnChegvj_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZhegvj_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSsygvj(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDsygvj(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnChegvj(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZhegvj(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCreateGesvdjInfo(info: *mut gesvdjInfo_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDestroyGesvdjInfo(info: gesvdjInfo_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgesvdjSetTolerance(info: gesvdjInfo_t, tolerance: f64) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgesvdjSetMaxSweeps(
        info: gesvdjInfo_t,
        max_sweeps: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgesvdjSetSortEig(
        info: gesvdjInfo_t,
        sort_svd: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgesvdjGetResidual(
        handle: cusolverDnHandle_t,
        info: gesvdjInfo_t,
        residual: *mut f64,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgesvdjGetSweeps(
        handle: cusolverDnHandle_t,
        info: gesvdjInfo_t,
        executed_sweeps: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgesvdjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        S: *const f32,
        U: *const f32,
        ldu: ::std::os::raw::c_int,
        V: *const f32,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgesvdjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        S: *const f64,
        U: *const f64,
        ldu: ::std::os::raw::c_int,
        V: *const f64,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgesvdjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        S: *const f32,
        U: *const cuComplex,
        ldu: ::std::os::raw::c_int,
        V: *const cuComplex,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgesvdjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        S: *const f64,
        U: *const cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        V: *const cuDoubleComplex,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgesvdjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        S: *mut f32,
        U: *mut f32,
        ldu: ::std::os::raw::c_int,
        V: *mut f32,
        ldv: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgesvdjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        S: *mut f64,
        U: *mut f64,
        ldu: ::std::os::raw::c_int,
        V: *mut f64,
        ldv: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgesvdjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        S: *mut f32,
        U: *mut cuComplex,
        ldu: ::std::os::raw::c_int,
        V: *mut cuComplex,
        ldv: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgesvdjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        S: *mut f64,
        U: *mut cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        V: *mut cuDoubleComplex,
        ldv: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgesvdj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        S: *const f32,
        U: *const f32,
        ldu: ::std::os::raw::c_int,
        V: *const f32,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgesvdj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        S: *const f64,
        U: *const f64,
        ldu: ::std::os::raw::c_int,
        V: *const f64,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgesvdj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        S: *const f32,
        U: *const cuComplex,
        ldu: ::std::os::raw::c_int,
        V: *const cuComplex,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgesvdj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        S: *const f64,
        U: *const cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        V: *const cuDoubleComplex,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgesvdj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        S: *mut f32,
        U: *mut f32,
        ldu: ::std::os::raw::c_int,
        V: *mut f32,
        ldv: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgesvdj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        S: *mut f64,
        U: *mut f64,
        ldu: ::std::os::raw::c_int,
        V: *mut f64,
        ldv: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgesvdj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        S: *mut f32,
        U: *mut cuComplex,
        ldu: ::std::os::raw::c_int,
        V: *mut cuComplex,
        ldv: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgesvdj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        S: *mut f64,
        U: *mut cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        V: *mut cuDoubleComplex,
        ldv: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgesvdaStridedBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *const f32,
        strideS: ::std::os::raw::c_longlong,
        d_U: *const f32,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *const f32,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        lwork: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgesvdaStridedBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *const f64,
        strideS: ::std::os::raw::c_longlong,
        d_U: *const f64,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *const f64,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        lwork: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgesvdaStridedBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *const f32,
        strideS: ::std::os::raw::c_longlong,
        d_U: *const cuComplex,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *const cuComplex,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        lwork: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgesvdaStridedBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *const f64,
        strideS: ::std::os::raw::c_longlong,
        d_U: *const cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *const cuDoubleComplex,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        lwork: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSgesvdaStridedBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *mut f32,
        strideS: ::std::os::raw::c_longlong,
        d_U: *mut f32,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *mut f32,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        d_work: *mut f32,
        lwork: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        h_R_nrmF: *mut f64,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDgesvdaStridedBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *mut f64,
        strideS: ::std::os::raw::c_longlong,
        d_U: *mut f64,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *mut f64,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        d_work: *mut f64,
        lwork: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        h_R_nrmF: *mut f64,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCgesvdaStridedBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *mut f32,
        strideS: ::std::os::raw::c_longlong,
        d_U: *mut cuComplex,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *mut cuComplex,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        d_work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        h_R_nrmF: *mut f64,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnZgesvdaStridedBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *mut f64,
        strideS: ::std::os::raw::c_longlong,
        d_U: *mut cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *mut cuDoubleComplex,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        d_work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        h_R_nrmF: *mut f64,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnCreateParams(params: *mut cusolverDnParams_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnDestroyParams(params: cusolverDnParams_t) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSetAdvOptions(
        params: cusolverDnParams_t,
        function: cusolverDnFunction_t,
        algo: cusolverAlgMode_t,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnPotrf_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        computeType: cudaDataType,
        workspaceInBytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnPotrf(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        computeType: cudaDataType,
        pBuffer: *mut ::std::os::raw::c_void,
        workspaceInBytes: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnPotrs(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        uplo: cublasFillMode_t,
        n: i64,
        nrhs: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeB: cudaDataType,
        B: *mut ::std::os::raw::c_void,
        ldb: i64,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnGeqrf_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeTau: cudaDataType,
        tau: *const ::std::os::raw::c_void,
        computeType: cudaDataType,
        workspaceInBytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnGeqrf(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeTau: cudaDataType,
        tau: *mut ::std::os::raw::c_void,
        computeType: cudaDataType,
        pBuffer: *mut ::std::os::raw::c_void,
        workspaceInBytes: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnGetrf_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        computeType: cudaDataType,
        workspaceInBytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnGetrf(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        ipiv: *mut i64,
        computeType: cudaDataType,
        pBuffer: *mut ::std::os::raw::c_void,
        workspaceInBytes: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnGetrs(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        trans: cublasOperation_t,
        n: i64,
        nrhs: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        ipiv: *const i64,
        dataTypeB: cudaDataType,
        B: *mut ::std::os::raw::c_void,
        ldb: i64,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSyevd_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeW: cudaDataType,
        W: *const ::std::os::raw::c_void,
        computeType: cudaDataType,
        workspaceInBytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSyevd(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeW: cudaDataType,
        W: *mut ::std::os::raw::c_void,
        computeType: cudaDataType,
        pBuffer: *mut ::std::os::raw::c_void,
        workspaceInBytes: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSyevdx_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        vl: *mut ::std::os::raw::c_void,
        vu: *mut ::std::os::raw::c_void,
        il: i64,
        iu: i64,
        h_meig: *mut i64,
        dataTypeW: cudaDataType,
        W: *const ::std::os::raw::c_void,
        computeType: cudaDataType,
        workspaceInBytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnSyevdx(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        vl: *mut ::std::os::raw::c_void,
        vu: *mut ::std::os::raw::c_void,
        il: i64,
        iu: i64,
        meig64: *mut i64,
        dataTypeW: cudaDataType,
        W: *mut ::std::os::raw::c_void,
        computeType: cudaDataType,
        pBuffer: *mut ::std::os::raw::c_void,
        workspaceInBytes: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnGesvd_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeS: cudaDataType,
        S: *const ::std::os::raw::c_void,
        dataTypeU: cudaDataType,
        U: *const ::std::os::raw::c_void,
        ldu: i64,
        dataTypeVT: cudaDataType,
        VT: *const ::std::os::raw::c_void,
        ldvt: i64,
        computeType: cudaDataType,
        workspaceInBytes: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnGesvd(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeS: cudaDataType,
        S: *mut ::std::os::raw::c_void,
        dataTypeU: cudaDataType,
        U: *mut ::std::os::raw::c_void,
        ldu: i64,
        dataTypeVT: cudaDataType,
        VT: *mut ::std::os::raw::c_void,
        ldvt: i64,
        computeType: cudaDataType,
        pBuffer: *mut ::std::os::raw::c_void,
        workspaceInBytes: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXpotrf_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXpotrf(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXpotrs(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        uplo: cublasFillMode_t,
        n: i64,
        nrhs: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeB: cudaDataType,
        B: *mut ::std::os::raw::c_void,
        ldb: i64,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgeqrf_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeTau: cudaDataType,
        tau: *const ::std::os::raw::c_void,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgeqrf(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeTau: cudaDataType,
        tau: *mut ::std::os::raw::c_void,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgetrf_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgetrf(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        ipiv: *mut i64,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgetrs(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        trans: cublasOperation_t,
        n: i64,
        nrhs: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        ipiv: *const i64,
        dataTypeB: cudaDataType,
        B: *mut ::std::os::raw::c_void,
        ldb: i64,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXsyevd_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeW: cudaDataType,
        W: *const ::std::os::raw::c_void,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXsyevd(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeW: cudaDataType,
        W: *mut ::std::os::raw::c_void,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXsyevdx_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        vl: *mut ::std::os::raw::c_void,
        vu: *mut ::std::os::raw::c_void,
        il: i64,
        iu: i64,
        h_meig: *mut i64,
        dataTypeW: cudaDataType,
        W: *const ::std::os::raw::c_void,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXsyevdx(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        vl: *mut ::std::os::raw::c_void,
        vu: *mut ::std::os::raw::c_void,
        il: i64,
        iu: i64,
        meig64: *mut i64,
        dataTypeW: cudaDataType,
        W: *mut ::std::os::raw::c_void,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgesvd_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeS: cudaDataType,
        S: *const ::std::os::raw::c_void,
        dataTypeU: cudaDataType,
        U: *const ::std::os::raw::c_void,
        ldu: i64,
        dataTypeVT: cudaDataType,
        VT: *const ::std::os::raw::c_void,
        ldvt: i64,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgesvd(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeS: cudaDataType,
        S: *mut ::std::os::raw::c_void,
        dataTypeU: cudaDataType,
        U: *mut ::std::os::raw::c_void,
        ldu: i64,
        dataTypeVT: cudaDataType,
        VT: *mut ::std::os::raw::c_void,
        ldvt: i64,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgesvdp_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeS: cudaDataType,
        S: *const ::std::os::raw::c_void,
        dataTypeU: cudaDataType,
        U: *const ::std::os::raw::c_void,
        ldu: i64,
        dataTypeV: cudaDataType,
        V: *const ::std::os::raw::c_void,
        ldv: i64,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgesvdp(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeS: cudaDataType,
        S: *mut ::std::os::raw::c_void,
        dataTypeU: cudaDataType,
        U: *mut ::std::os::raw::c_void,
        ldu: i64,
        dataTypeV: cudaDataType,
        V: *mut ::std::os::raw::c_void,
        ldv: i64,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        d_info: *mut ::std::os::raw::c_int,
        h_err_sigma: *mut f64,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgesvdr_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobu: ::std::os::raw::c_schar,
        jobv: ::std::os::raw::c_schar,
        m: i64,
        n: i64,
        k: i64,
        p: i64,
        niters: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeSrand: cudaDataType,
        Srand: *const ::std::os::raw::c_void,
        dataTypeUrand: cudaDataType,
        Urand: *const ::std::os::raw::c_void,
        ldUrand: i64,
        dataTypeVrand: cudaDataType,
        Vrand: *const ::std::os::raw::c_void,
        ldVrand: i64,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
extern "C" {
    pub fn cusolverDnXgesvdr(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobu: ::std::os::raw::c_schar,
        jobv: ::std::os::raw::c_schar,
        m: i64,
        n: i64,
        k: i64,
        p: i64,
        niters: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeSrand: cudaDataType,
        Srand: *mut ::std::os::raw::c_void,
        dataTypeUrand: cudaDataType,
        Urand: *mut ::std::os::raw::c_void,
        ldUrand: i64,
        dataTypeVrand: cudaDataType,
        Vrand: *mut ::std::os::raw::c_void,
        ldVrand: i64,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        d_info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
